{
  "wxml": [
    {
      "tag": "import",
      "attrs": {
        "src": "./calendar.wxml"
      }
    },
    {
      "tag": "van-popup",
      "attrs": {
        "v-if": "poppable",
        "custom-class": "van-calendar__popup--{{ position }}",
        "close-icon-class": "van-calendar__close-icon",
        ":show": "show",
        ":round": "round",
        ":position": "position",
        ":closeable": "showTitle || showSubtitle",
        ":close-on-click-overlay": "closeOnClickOverlay",
        ":safe-area-inset-bottom": "safeAreaInsetBottom",
        ":root-portal": "rootPortal",
        "@enter": "onOpen",
        "@close": "onClose",
        "@after-enter": "onOpened",
        "@after-leave": "onClosed"
      },
      "children": [
        {
          "tag": "include",
          "attrs": {
            "src": "./calendar.wxml"
          }
        }
      ]
    },
    {
      "tag": "include",
      "attrs": {
        "v-else": "",
        "src": "./calendar.wxml"
      }
    },
    {
      "tag": "van-toast",
      "attrs": {
        "id": "van-toast"
      }
    }
  ],
  "ts": {
    "kind": "SourceFile",
    "text": "import { VantComponent } from '../common/component';\nimport {\n  ROW_HEIGHT,\n  getPrevDay,\n  getNextDay,\n  getToday,\n  compareDay,\n  copyDates,\n  calcDateNum,\n  formatMonthTitle,\n  compareMonth,\n  getMonths,\n  getDayByOffset,\n} from './utils';\nimport { Day } from './components/month/index';\n\nimport Toast from '../toast/toast';\nimport { requestAnimationFrame } from '../common/utils';\n\nconst initialMinDate = getToday().getTime();\n\nconst initialMaxDate = (() => {\n  const now = getToday();\n  return new Date(\n    now.getFullYear(),\n    now.getMonth() + 6,\n    now.getDate()\n  ).getTime();\n})();\n\nconst getTime = (date: Date | number) =>\n  date instanceof Date ? date.getTime() : date;\n\nVantComponent({\n  props: {\n    title: {\n      type: String,\n      value: '日期选择',\n    },\n    color: String,\n    show: {\n      type: Boolean,\n      observer(val) {\n        if (val) {\n          this.initRect();\n          this.scrollIntoView();\n        }\n      },\n    },\n    formatter: null,\n    confirmText: {\n      type: String,\n      value: '确定',\n    },\n    confirmDisabledText: {\n      type: String,\n      value: '确定',\n    },\n    rangePrompt: String,\n    showRangePrompt: {\n      type: Boolean,\n      value: true,\n    },\n    defaultDate: {\n      type: null,\n      value: getToday().getTime(),\n      observer(val) {\n        this.setData({ currentDate: val });\n        this.scrollIntoView();\n      },\n    },\n    allowSameDay: Boolean,\n    type: {\n      type: String,\n      value: 'single',\n      observer: 'reset',\n    },\n    minDate: {\n      type: Number,\n      value: initialMinDate,\n    },\n    maxDate: {\n      type: Number,\n      value: initialMaxDate,\n    },\n    position: {\n      type: String,\n      value: 'bottom',\n    },\n    rowHeight: {\n      type: null,\n      value: ROW_HEIGHT,\n    },\n    round: {\n      type: Boolean,\n      value: true,\n    },\n    poppable: {\n      type: Boolean,\n      value: true,\n    },\n    showMark: {\n      type: Boolean,\n      value: true,\n    },\n    showTitle: {\n      type: Boolean,\n      value: true,\n    },\n    showConfirm: {\n      type: Boolean,\n      value: true,\n    },\n    showSubtitle: {\n      type: Boolean,\n      value: true,\n    },\n    safeAreaInsetBottom: {\n      type: Boolean,\n      value: true,\n    },\n    closeOnClickOverlay: {\n      type: Boolean,\n      value: true,\n    },\n    maxRange: {\n      type: null,\n      value: null,\n    },\n    minRange: {\n      type: Number,\n      value: 1,\n    },\n    firstDayOfWeek: {\n      type: Number,\n      value: 0,\n    },\n    readonly: Boolean,\n    rootPortal: {\n      type: Boolean,\n      value: false,\n    },\n  },\n\n  data: {\n    subtitle: '',\n    currentDate: null as any,\n    scrollIntoView: '',\n  },\n\n  watch: {\n    minDate() {\n      this.initRect();\n    },\n    maxDate() {\n      this.initRect();\n    },\n  },\n\n  created() {\n    this.setData({\n      currentDate: this.getInitialDate(this.data.defaultDate),\n    });\n  },\n\n  mounted() {\n    if (this.data.show || !this.data.poppable) {\n      this.initRect();\n      this.scrollIntoView();\n    }\n  },\n\n  methods: {\n    reset() {\n      this.setData({ currentDate: this.getInitialDate(this.data.defaultDate) });\n      this.scrollIntoView();\n    },\n\n    initRect() {\n      if (this.contentObserver != null) {\n        this.contentObserver.disconnect();\n      }\n\n      const contentObserver = this.createIntersectionObserver({\n        thresholds: [0, 0.1, 0.9, 1],\n        observeAll: true,\n      });\n\n      this.contentObserver = contentObserver;\n\n      contentObserver.relativeTo('.van-calendar__body');\n      contentObserver.observe('.month', (res) => {\n        if (res.boundingClientRect.top <= res.relativeRect.top) {\n          // @ts-ignore\n          this.setData({ subtitle: formatMonthTitle(res.dataset.date) });\n        }\n      });\n    },\n\n    limitDateRange(\n      date: number,\n      minDate: number | null = null,\n      maxDate: number | null = null\n    ) {\n      minDate = minDate || (this.data.minDate as number);\n      maxDate = maxDate || (this.data.maxDate as number);\n      if (compareDay(date, minDate) === -1) {\n        return minDate;\n      }\n      if (compareDay(date, maxDate) === 1) {\n        return maxDate;\n      }\n      return date;\n    },\n\n    getInitialDate(defaultDate: number | number[] | null = null) {\n      const { type, minDate, maxDate, allowSameDay } = this.data;\n\n      if (!defaultDate) return [];\n\n      const now = getToday().getTime();\n\n      if (type === 'range') {\n        if (!Array.isArray(defaultDate)) {\n          defaultDate = [];\n        }\n\n        const [startDay, endDay] = defaultDate || [];\n\n        const startDate = getTime(startDay || now);\n        const start = this.limitDateRange(\n          startDate,\n          minDate,\n          allowSameDay ? startDate : getPrevDay(new Date(maxDate)).getTime()\n        );\n\n        const date = getTime(endDay || now);\n        const end = this.limitDateRange(\n          date,\n          allowSameDay ? date : getNextDay(new Date(minDate)).getTime()\n        );\n\n        return [start, end];\n      }\n\n      if (type === 'multiple') {\n        if (Array.isArray(defaultDate)) {\n          return defaultDate.map((date) => this.limitDateRange(date));\n        }\n\n        return [this.limitDateRange(now)];\n      }\n\n      if (!defaultDate || Array.isArray(defaultDate)) {\n        defaultDate = now;\n      }\n      return this.limitDateRange(defaultDate);\n    },\n\n    scrollIntoView() {\n      requestAnimationFrame(() => {\n        const { currentDate, type, show, poppable, minDate, maxDate } =\n          this.data;\n        if (!currentDate) return;\n        // @ts-ignore\n        const targetDate = type === 'single' ? currentDate : currentDate[0];\n        const displayed = show || !poppable;\n        if (!targetDate || !displayed) {\n          return;\n        }\n\n        const months = getMonths(minDate, maxDate);\n\n        months.some((month, index) => {\n          if (compareMonth(month, targetDate) === 0) {\n            this.setData({ scrollIntoView: `month${index}` });\n            return true;\n          }\n\n          return false;\n        });\n      });\n    },\n\n    onOpen() {\n      this.$emit('open');\n    },\n\n    onOpened() {\n      this.$emit('opened');\n    },\n\n    onClose() {\n      this.$emit('close');\n    },\n\n    onClosed() {\n      this.$emit('closed');\n    },\n\n    onClickDay(event) {\n      if (this.data.readonly) {\n        return;\n      }\n\n      let { date } = event.detail;\n      const { type, currentDate, allowSameDay } = this.data;\n\n      if (type === 'range') {\n        // @ts-ignore\n        const [startDay, endDay] = currentDate;\n\n        if (startDay && !endDay) {\n          const compareToStart = compareDay(date, startDay);\n\n          if (compareToStart === 1) {\n            const { days } = this.selectComponent('.month').data;\n            days.some((day: Day, index) => {\n              const isDisabled =\n                day.type === 'disabled' &&\n                getTime(startDay) < getTime(day.date) &&\n                getTime(day.date) < getTime(date);\n              if (isDisabled) {\n                ({ date } = days[index - 1]);\n              }\n              return isDisabled;\n            });\n            this.select([startDay, date], true);\n          } else if (compareToStart === -1) {\n            this.select([date, null]);\n          } else if (allowSameDay) {\n            this.select([date, date], true);\n          }\n        } else {\n          this.select([date, null]);\n        }\n      } else if (type === 'multiple') {\n        let selectedIndex: number;\n\n        // @ts-ignore\n        const selected = currentDate.some((dateItem: number, index: number) => {\n          const equal = compareDay(dateItem, date) === 0;\n          if (equal) {\n            selectedIndex = index;\n          }\n          return equal;\n        });\n\n        if (selected) {\n          // @ts-ignore\n          const cancelDate = currentDate.splice(selectedIndex, 1);\n          this.setData({ currentDate });\n          this.unselect(cancelDate);\n        } else {\n          // @ts-ignore\n          this.select([...currentDate, date]);\n        }\n      } else {\n        this.select(date, true);\n      }\n    },\n\n    unselect(dateArray) {\n      const date = dateArray[0];\n      if (date) {\n        this.$emit('unselect', copyDates(date));\n      }\n    },\n\n    select(date, complete?: boolean) {\n      if (complete && this.data.type === 'range') {\n        const valid = this.checkRange(date);\n\n        if (!valid) {\n          // auto selected to max range if showConfirm\n          if (this.data.showConfirm) {\n            this.emit([\n              date[0],\n              getDayByOffset(date[0], this.data.maxRange - 1),\n            ]);\n          } else {\n            this.emit(date);\n          }\n          return;\n        }\n      }\n\n      this.emit(date);\n\n      if (complete && !this.data.showConfirm) {\n        this.onConfirm();\n      }\n    },\n\n    emit(date) {\n      this.setData({\n        currentDate: Array.isArray(date) ? date.map(getTime) : getTime(date),\n      });\n      this.$emit('select', copyDates(date));\n    },\n\n    checkRange(date) {\n      const { maxRange, rangePrompt, showRangePrompt } = this.data;\n\n      if (maxRange && calcDateNum(date) > maxRange) {\n        if (showRangePrompt) {\n          Toast({\n            context: this,\n            message: rangePrompt || `选择天数不能超过 ${maxRange} 天`,\n          });\n        }\n        this.$emit('over-range');\n\n        return false;\n      }\n\n      return true;\n    },\n\n    onConfirm() {\n      if (\n        this.data.type === 'range' &&\n        !this.checkRange(this.data.currentDate)\n      ) {\n        return;\n      }\n      wx.nextTick(() => {\n        // @ts-ignore\n        this.$emit('confirm', copyDates(this.data.currentDate));\n      });\n    },\n\n    onClickSubtitle(event: WechatMiniprogram.TouchEvent) {\n      this.$emit('click-subtitle', event);\n    },\n  },\n});\n",
    "statements": [
      {
        "kind": "ImportDeclaration",
        "text": "import { VantComponent } from '../common/component';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import {\n  ROW_HEIGHT,\n  getPrevDay,\n  getNextDay,\n  getToday,\n  compareDay,\n  copyDates,\n  calcDateNum,\n  formatMonthTitle,\n  compareMonth,\n  getMonths,\n  getDayByOffset,\n} from './utils';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { Day } from './components/month/index';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import Toast from '../toast/toast';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { requestAnimationFrame } from '../common/utils';"
      },
      {
        "kind": "FirstStatement",
        "text": "const initialMinDate = getToday().getTime();"
      },
      {
        "kind": "FirstStatement",
        "text": "const initialMaxDate = (() => {\n  const now = getToday();\n  return new Date(\n    now.getFullYear(),\n    now.getMonth() + 6,\n    now.getDate()\n  ).getTime();\n})();"
      },
      {
        "kind": "FirstStatement",
        "text": "const getTime = (date: Date | number) =>\n  date instanceof Date ? date.getTime() : date;"
      },
      {
        "kind": "ExpressionStatement",
        "text": "VantComponent({\n  props: {\n    title: {\n      type: String,\n      value: '日期选择',\n    },\n    color: String,\n    show: {\n      type: Boolean,\n      observer(val) {\n        if (val) {\n          this.initRect();\n          this.scrollIntoView();\n        }\n      },\n    },\n    formatter: null,\n    confirmText: {\n      type: String,\n      value: '确定',\n    },\n    confirmDisabledText: {\n      type: String,\n      value: '确定',\n    },\n    rangePrompt: String,\n    showRangePrompt: {\n      type: Boolean,\n      value: true,\n    },\n    defaultDate: {\n      type: null,\n      value: getToday().getTime(),\n      observer(val) {\n        this.setData({ currentDate: val });\n        this.scrollIntoView();\n      },\n    },\n    allowSameDay: Boolean,\n    type: {\n      type: String,\n      value: 'single',\n      observer: 'reset',\n    },\n    minDate: {\n      type: Number,\n      value: initialMinDate,\n    },\n    maxDate: {\n      type: Number,\n      value: initialMaxDate,\n    },\n    position: {\n      type: String,\n      value: 'bottom',\n    },\n    rowHeight: {\n      type: null,\n      value: ROW_HEIGHT,\n    },\n    round: {\n      type: Boolean,\n      value: true,\n    },\n    poppable: {\n      type: Boolean,\n      value: true,\n    },\n    showMark: {\n      type: Boolean,\n      value: true,\n    },\n    showTitle: {\n      type: Boolean,\n      value: true,\n    },\n    showConfirm: {\n      type: Boolean,\n      value: true,\n    },\n    showSubtitle: {\n      type: Boolean,\n      value: true,\n    },\n    safeAreaInsetBottom: {\n      type: Boolean,\n      value: true,\n    },\n    closeOnClickOverlay: {\n      type: Boolean,\n      value: true,\n    },\n    maxRange: {\n      type: null,\n      value: null,\n    },\n    minRange: {\n      type: Number,\n      value: 1,\n    },\n    firstDayOfWeek: {\n      type: Number,\n      value: 0,\n    },\n    readonly: Boolean,\n    rootPortal: {\n      type: Boolean,\n      value: false,\n    },\n  },\n\n  data: {\n    subtitle: '',\n    currentDate: null as any,\n    scrollIntoView: '',\n  },\n\n  watch: {\n    minDate() {\n      this.initRect();\n    },\n    maxDate() {\n      this.initRect();\n    },\n  },\n\n  created() {\n    this.setData({\n      currentDate: this.getInitialDate(this.data.defaultDate),\n    });\n  },\n\n  mounted() {\n    if (this.data.show || !this.data.poppable) {\n      this.initRect();\n      this.scrollIntoView();\n    }\n  },\n\n  methods: {\n    reset() {\n      this.setData({ currentDate: this.getInitialDate(this.data.defaultDate) });\n      this.scrollIntoView();\n    },\n\n    initRect() {\n      if (this.contentObserver != null) {\n        this.contentObserver.disconnect();\n      }\n\n      const contentObserver = this.createIntersectionObserver({\n        thresholds: [0, 0.1, 0.9, 1],\n        observeAll: true,\n      });\n\n      this.contentObserver = contentObserver;\n\n      contentObserver.relativeTo('.van-calendar__body');\n      contentObserver.observe('.month', (res) => {\n        if (res.boundingClientRect.top <= res.relativeRect.top) {\n          // @ts-ignore\n          this.setData({ subtitle: formatMonthTitle(res.dataset.date) });\n        }\n      });\n    },\n\n    limitDateRange(\n      date: number,\n      minDate: number | null = null,\n      maxDate: number | null = null\n    ) {\n      minDate = minDate || (this.data.minDate as number);\n      maxDate = maxDate || (this.data.maxDate as number);\n      if (compareDay(date, minDate) === -1) {\n        return minDate;\n      }\n      if (compareDay(date, maxDate) === 1) {\n        return maxDate;\n      }\n      return date;\n    },\n\n    getInitialDate(defaultDate: number | number[] | null = null) {\n      const { type, minDate, maxDate, allowSameDay } = this.data;\n\n      if (!defaultDate) return [];\n\n      const now = getToday().getTime();\n\n      if (type === 'range') {\n        if (!Array.isArray(defaultDate)) {\n          defaultDate = [];\n        }\n\n        const [startDay, endDay] = defaultDate || [];\n\n        const startDate = getTime(startDay || now);\n        const start = this.limitDateRange(\n          startDate,\n          minDate,\n          allowSameDay ? startDate : getPrevDay(new Date(maxDate)).getTime()\n        );\n\n        const date = getTime(endDay || now);\n        const end = this.limitDateRange(\n          date,\n          allowSameDay ? date : getNextDay(new Date(minDate)).getTime()\n        );\n\n        return [start, end];\n      }\n\n      if (type === 'multiple') {\n        if (Array.isArray(defaultDate)) {\n          return defaultDate.map((date) => this.limitDateRange(date));\n        }\n\n        return [this.limitDateRange(now)];\n      }\n\n      if (!defaultDate || Array.isArray(defaultDate)) {\n        defaultDate = now;\n      }\n      return this.limitDateRange(defaultDate);\n    },\n\n    scrollIntoView() {\n      requestAnimationFrame(() => {\n        const { currentDate, type, show, poppable, minDate, maxDate } =\n          this.data;\n        if (!currentDate) return;\n        // @ts-ignore\n        const targetDate = type === 'single' ? currentDate : currentDate[0];\n        const displayed = show || !poppable;\n        if (!targetDate || !displayed) {\n          return;\n        }\n\n        const months = getMonths(minDate, maxDate);\n\n        months.some((month, index) => {\n          if (compareMonth(month, targetDate) === 0) {\n            this.setData({ scrollIntoView: `month${index}` });\n            return true;\n          }\n\n          return false;\n        });\n      });\n    },\n\n    onOpen() {\n      this.$emit('open');\n    },\n\n    onOpened() {\n      this.$emit('opened');\n    },\n\n    onClose() {\n      this.$emit('close');\n    },\n\n    onClosed() {\n      this.$emit('closed');\n    },\n\n    onClickDay(event) {\n      if (this.data.readonly) {\n        return;\n      }\n\n      let { date } = event.detail;\n      const { type, currentDate, allowSameDay } = this.data;\n\n      if (type === 'range') {\n        // @ts-ignore\n        const [startDay, endDay] = currentDate;\n\n        if (startDay && !endDay) {\n          const compareToStart = compareDay(date, startDay);\n\n          if (compareToStart === 1) {\n            const { days } = this.selectComponent('.month').data;\n            days.some((day: Day, index) => {\n              const isDisabled =\n                day.type === 'disabled' &&\n                getTime(startDay) < getTime(day.date) &&\n                getTime(day.date) < getTime(date);\n              if (isDisabled) {\n                ({ date } = days[index - 1]);\n              }\n              return isDisabled;\n            });\n            this.select([startDay, date], true);\n          } else if (compareToStart === -1) {\n            this.select([date, null]);\n          } else if (allowSameDay) {\n            this.select([date, date], true);\n          }\n        } else {\n          this.select([date, null]);\n        }\n      } else if (type === 'multiple') {\n        let selectedIndex: number;\n\n        // @ts-ignore\n        const selected = currentDate.some((dateItem: number, index: number) => {\n          const equal = compareDay(dateItem, date) === 0;\n          if (equal) {\n            selectedIndex = index;\n          }\n          return equal;\n        });\n\n        if (selected) {\n          // @ts-ignore\n          const cancelDate = currentDate.splice(selectedIndex, 1);\n          this.setData({ currentDate });\n          this.unselect(cancelDate);\n        } else {\n          // @ts-ignore\n          this.select([...currentDate, date]);\n        }\n      } else {\n        this.select(date, true);\n      }\n    },\n\n    unselect(dateArray) {\n      const date = dateArray[0];\n      if (date) {\n        this.$emit('unselect', copyDates(date));\n      }\n    },\n\n    select(date, complete?: boolean) {\n      if (complete && this.data.type === 'range') {\n        const valid = this.checkRange(date);\n\n        if (!valid) {\n          // auto selected to max range if showConfirm\n          if (this.data.showConfirm) {\n            this.emit([\n              date[0],\n              getDayByOffset(date[0], this.data.maxRange - 1),\n            ]);\n          } else {\n            this.emit(date);\n          }\n          return;\n        }\n      }\n\n      this.emit(date);\n\n      if (complete && !this.data.showConfirm) {\n        this.onConfirm();\n      }\n    },\n\n    emit(date) {\n      this.setData({\n        currentDate: Array.isArray(date) ? date.map(getTime) : getTime(date),\n      });\n      this.$emit('select', copyDates(date));\n    },\n\n    checkRange(date) {\n      const { maxRange, rangePrompt, showRangePrompt } = this.data;\n\n      if (maxRange && calcDateNum(date) > maxRange) {\n        if (showRangePrompt) {\n          Toast({\n            context: this,\n            message: rangePrompt || `选择天数不能超过 ${maxRange} 天`,\n          });\n        }\n        this.$emit('over-range');\n\n        return false;\n      }\n\n      return true;\n    },\n\n    onConfirm() {\n      if (\n        this.data.type === 'range' &&\n        !this.checkRange(this.data.currentDate)\n      ) {\n        return;\n      }\n      wx.nextTick(() => {\n        // @ts-ignore\n        this.$emit('confirm', copyDates(this.data.currentDate));\n      });\n    },\n\n    onClickSubtitle(event: WechatMiniprogram.TouchEvent) {\n      this.$emit('click-subtitle', event);\n    },\n  },\n});",
        "expression": "VantComponent({\n  props: {\n    title: {\n      type: String,\n      value: '日期选择',\n    },\n    color: String,\n    show: {\n      type: Boolean,\n      observer(val) {\n        if (val) {\n          this.initRect();\n          this.scrollIntoView();\n        }\n      },\n    },\n    formatter: null,\n    confirmText: {\n      type: String,\n      value: '确定',\n    },\n    confirmDisabledText: {\n      type: String,\n      value: '确定',\n    },\n    rangePrompt: String,\n    showRangePrompt: {\n      type: Boolean,\n      value: true,\n    },\n    defaultDate: {\n      type: null,\n      value: getToday().getTime(),\n      observer(val) {\n        this.setData({ currentDate: val });\n        this.scrollIntoView();\n      },\n    },\n    allowSameDay: Boolean,\n    type: {\n      type: String,\n      value: 'single',\n      observer: 'reset',\n    },\n    minDate: {\n      type: Number,\n      value: initialMinDate,\n    },\n    maxDate: {\n      type: Number,\n      value: initialMaxDate,\n    },\n    position: {\n      type: String,\n      value: 'bottom',\n    },\n    rowHeight: {\n      type: null,\n      value: ROW_HEIGHT,\n    },\n    round: {\n      type: Boolean,\n      value: true,\n    },\n    poppable: {\n      type: Boolean,\n      value: true,\n    },\n    showMark: {\n      type: Boolean,\n      value: true,\n    },\n    showTitle: {\n      type: Boolean,\n      value: true,\n    },\n    showConfirm: {\n      type: Boolean,\n      value: true,\n    },\n    showSubtitle: {\n      type: Boolean,\n      value: true,\n    },\n    safeAreaInsetBottom: {\n      type: Boolean,\n      value: true,\n    },\n    closeOnClickOverlay: {\n      type: Boolean,\n      value: true,\n    },\n    maxRange: {\n      type: null,\n      value: null,\n    },\n    minRange: {\n      type: Number,\n      value: 1,\n    },\n    firstDayOfWeek: {\n      type: Number,\n      value: 0,\n    },\n    readonly: Boolean,\n    rootPortal: {\n      type: Boolean,\n      value: false,\n    },\n  },\n\n  data: {\n    subtitle: '',\n    currentDate: null as any,\n    scrollIntoView: '',\n  },\n\n  watch: {\n    minDate() {\n      this.initRect();\n    },\n    maxDate() {\n      this.initRect();\n    },\n  },\n\n  created() {\n    this.setData({\n      currentDate: this.getInitialDate(this.data.defaultDate),\n    });\n  },\n\n  mounted() {\n    if (this.data.show || !this.data.poppable) {\n      this.initRect();\n      this.scrollIntoView();\n    }\n  },\n\n  methods: {\n    reset() {\n      this.setData({ currentDate: this.getInitialDate(this.data.defaultDate) });\n      this.scrollIntoView();\n    },\n\n    initRect() {\n      if (this.contentObserver != null) {\n        this.contentObserver.disconnect();\n      }\n\n      const contentObserver = this.createIntersectionObserver({\n        thresholds: [0, 0.1, 0.9, 1],\n        observeAll: true,\n      });\n\n      this.contentObserver = contentObserver;\n\n      contentObserver.relativeTo('.van-calendar__body');\n      contentObserver.observe('.month', (res) => {\n        if (res.boundingClientRect.top <= res.relativeRect.top) {\n          // @ts-ignore\n          this.setData({ subtitle: formatMonthTitle(res.dataset.date) });\n        }\n      });\n    },\n\n    limitDateRange(\n      date: number,\n      minDate: number | null = null,\n      maxDate: number | null = null\n    ) {\n      minDate = minDate || (this.data.minDate as number);\n      maxDate = maxDate || (this.data.maxDate as number);\n      if (compareDay(date, minDate) === -1) {\n        return minDate;\n      }\n      if (compareDay(date, maxDate) === 1) {\n        return maxDate;\n      }\n      return date;\n    },\n\n    getInitialDate(defaultDate: number | number[] | null = null) {\n      const { type, minDate, maxDate, allowSameDay } = this.data;\n\n      if (!defaultDate) return [];\n\n      const now = getToday().getTime();\n\n      if (type === 'range') {\n        if (!Array.isArray(defaultDate)) {\n          defaultDate = [];\n        }\n\n        const [startDay, endDay] = defaultDate || [];\n\n        const startDate = getTime(startDay || now);\n        const start = this.limitDateRange(\n          startDate,\n          minDate,\n          allowSameDay ? startDate : getPrevDay(new Date(maxDate)).getTime()\n        );\n\n        const date = getTime(endDay || now);\n        const end = this.limitDateRange(\n          date,\n          allowSameDay ? date : getNextDay(new Date(minDate)).getTime()\n        );\n\n        return [start, end];\n      }\n\n      if (type === 'multiple') {\n        if (Array.isArray(defaultDate)) {\n          return defaultDate.map((date) => this.limitDateRange(date));\n        }\n\n        return [this.limitDateRange(now)];\n      }\n\n      if (!defaultDate || Array.isArray(defaultDate)) {\n        defaultDate = now;\n      }\n      return this.limitDateRange(defaultDate);\n    },\n\n    scrollIntoView() {\n      requestAnimationFrame(() => {\n        const { currentDate, type, show, poppable, minDate, maxDate } =\n          this.data;\n        if (!currentDate) return;\n        // @ts-ignore\n        const targetDate = type === 'single' ? currentDate : currentDate[0];\n        const displayed = show || !poppable;\n        if (!targetDate || !displayed) {\n          return;\n        }\n\n        const months = getMonths(minDate, maxDate);\n\n        months.some((month, index) => {\n          if (compareMonth(month, targetDate) === 0) {\n            this.setData({ scrollIntoView: `month${index}` });\n            return true;\n          }\n\n          return false;\n        });\n      });\n    },\n\n    onOpen() {\n      this.$emit('open');\n    },\n\n    onOpened() {\n      this.$emit('opened');\n    },\n\n    onClose() {\n      this.$emit('close');\n    },\n\n    onClosed() {\n      this.$emit('closed');\n    },\n\n    onClickDay(event) {\n      if (this.data.readonly) {\n        return;\n      }\n\n      let { date } = event.detail;\n      const { type, currentDate, allowSameDay } = this.data;\n\n      if (type === 'range') {\n        // @ts-ignore\n        const [startDay, endDay] = currentDate;\n\n        if (startDay && !endDay) {\n          const compareToStart = compareDay(date, startDay);\n\n          if (compareToStart === 1) {\n            const { days } = this.selectComponent('.month').data;\n            days.some((day: Day, index) => {\n              const isDisabled =\n                day.type === 'disabled' &&\n                getTime(startDay) < getTime(day.date) &&\n                getTime(day.date) < getTime(date);\n              if (isDisabled) {\n                ({ date } = days[index - 1]);\n              }\n              return isDisabled;\n            });\n            this.select([startDay, date], true);\n          } else if (compareToStart === -1) {\n            this.select([date, null]);\n          } else if (allowSameDay) {\n            this.select([date, date], true);\n          }\n        } else {\n          this.select([date, null]);\n        }\n      } else if (type === 'multiple') {\n        let selectedIndex: number;\n\n        // @ts-ignore\n        const selected = currentDate.some((dateItem: number, index: number) => {\n          const equal = compareDay(dateItem, date) === 0;\n          if (equal) {\n            selectedIndex = index;\n          }\n          return equal;\n        });\n\n        if (selected) {\n          // @ts-ignore\n          const cancelDate = currentDate.splice(selectedIndex, 1);\n          this.setData({ currentDate });\n          this.unselect(cancelDate);\n        } else {\n          // @ts-ignore\n          this.select([...currentDate, date]);\n        }\n      } else {\n        this.select(date, true);\n      }\n    },\n\n    unselect(dateArray) {\n      const date = dateArray[0];\n      if (date) {\n        this.$emit('unselect', copyDates(date));\n      }\n    },\n\n    select(date, complete?: boolean) {\n      if (complete && this.data.type === 'range') {\n        const valid = this.checkRange(date);\n\n        if (!valid) {\n          // auto selected to max range if showConfirm\n          if (this.data.showConfirm) {\n            this.emit([\n              date[0],\n              getDayByOffset(date[0], this.data.maxRange - 1),\n            ]);\n          } else {\n            this.emit(date);\n          }\n          return;\n        }\n      }\n\n      this.emit(date);\n\n      if (complete && !this.data.showConfirm) {\n        this.onConfirm();\n      }\n    },\n\n    emit(date) {\n      this.setData({\n        currentDate: Array.isArray(date) ? date.map(getTime) : getTime(date),\n      });\n      this.$emit('select', copyDates(date));\n    },\n\n    checkRange(date) {\n      const { maxRange, rangePrompt, showRangePrompt } = this.data;\n\n      if (maxRange && calcDateNum(date) > maxRange) {\n        if (showRangePrompt) {\n          Toast({\n            context: this,\n            message: rangePrompt || `选择天数不能超过 ${maxRange} 天`,\n          });\n        }\n        this.$emit('over-range');\n\n        return false;\n      }\n\n      return true;\n    },\n\n    onConfirm() {\n      if (\n        this.data.type === 'range' &&\n        !this.checkRange(this.data.currentDate)\n      ) {\n        return;\n      }\n      wx.nextTick(() => {\n        // @ts-ignore\n        this.$emit('confirm', copyDates(this.data.currentDate));\n      });\n    },\n\n    onClickSubtitle(event: WechatMiniprogram.TouchEvent) {\n      this.$emit('click-subtitle', event);\n    },\n  },\n})",
        "callee": "VantComponent",
        "arguments": [
          {
            "props": {
              "title": {
                "type": "String",
                "value": "日期选择"
              },
              "color": "String",
              "show": {
                "type": "Boolean"
              },
              "formatter": "null",
              "confirmText": {
                "type": "String",
                "value": "确定"
              },
              "confirmDisabledText": {
                "type": "String",
                "value": "确定"
              },
              "rangePrompt": "String",
              "showRangePrompt": {
                "type": "Boolean",
                "value": "true"
              },
              "defaultDate": {
                "type": "null",
                "value": "getToday().getTime()"
              },
              "allowSameDay": "Boolean",
              "type": {
                "type": "String",
                "value": "single",
                "observer": "reset"
              },
              "minDate": {
                "type": "Number",
                "value": "initialMinDate"
              },
              "maxDate": {
                "type": "Number",
                "value": "initialMaxDate"
              },
              "position": {
                "type": "String",
                "value": "bottom"
              },
              "rowHeight": {
                "type": "null",
                "value": "ROW_HEIGHT"
              },
              "round": {
                "type": "Boolean",
                "value": "true"
              },
              "poppable": {
                "type": "Boolean",
                "value": "true"
              },
              "showMark": {
                "type": "Boolean",
                "value": "true"
              },
              "showTitle": {
                "type": "Boolean",
                "value": "true"
              },
              "showConfirm": {
                "type": "Boolean",
                "value": "true"
              },
              "showSubtitle": {
                "type": "Boolean",
                "value": "true"
              },
              "safeAreaInsetBottom": {
                "type": "Boolean",
                "value": "true"
              },
              "closeOnClickOverlay": {
                "type": "Boolean",
                "value": "true"
              },
              "maxRange": {
                "type": "null",
                "value": "null"
              },
              "minRange": {
                "type": "Number",
                "value": "1"
              },
              "firstDayOfWeek": {
                "type": "Number",
                "value": "0"
              },
              "readonly": "Boolean",
              "rootPortal": {
                "type": "Boolean",
                "value": "false"
              }
            },
            "data": {
              "subtitle": "",
              "currentDate": "null as any",
              "scrollIntoView": ""
            },
            "watch": {},
            "methods": {
              "reset": "reset() {\n      this.setData({ currentDate: this.getInitialDate(this.data.defaultDate) });\n      this.scrollIntoView();\n    }",
              "initRect": "initRect() {\n      if (this.contentObserver != null) {\n        this.contentObserver.disconnect();\n      }\n\n      const contentObserver = this.createIntersectionObserver({\n        thresholds: [0, 0.1, 0.9, 1],\n        observeAll: true,\n      });\n\n      this.contentObserver = contentObserver;\n\n      contentObserver.relativeTo('.van-calendar__body');\n      contentObserver.observe('.month', (res) => {\n        if (res.boundingClientRect.top <= res.relativeRect.top) {\n          // @ts-ignore\n          this.setData({ subtitle: formatMonthTitle(res.dataset.date) });\n        }\n      });\n    }",
              "limitDateRange": "limitDateRange(\n      date: number,\n      minDate: number | null = null,\n      maxDate: number | null = null\n    ) {\n      minDate = minDate || (this.data.minDate as number);\n      maxDate = maxDate || (this.data.maxDate as number);\n      if (compareDay(date, minDate) === -1) {\n        return minDate;\n      }\n      if (compareDay(date, maxDate) === 1) {\n        return maxDate;\n      }\n      return date;\n    }",
              "getInitialDate": "getInitialDate(defaultDate: number | number[] | null = null) {\n      const { type, minDate, maxDate, allowSameDay } = this.data;\n\n      if (!defaultDate) return [];\n\n      const now = getToday().getTime();\n\n      if (type === 'range') {\n        if (!Array.isArray(defaultDate)) {\n          defaultDate = [];\n        }\n\n        const [startDay, endDay] = defaultDate || [];\n\n        const startDate = getTime(startDay || now);\n        const start = this.limitDateRange(\n          startDate,\n          minDate,\n          allowSameDay ? startDate : getPrevDay(new Date(maxDate)).getTime()\n        );\n\n        const date = getTime(endDay || now);\n        const end = this.limitDateRange(\n          date,\n          allowSameDay ? date : getNextDay(new Date(minDate)).getTime()\n        );\n\n        return [start, end];\n      }\n\n      if (type === 'multiple') {\n        if (Array.isArray(defaultDate)) {\n          return defaultDate.map((date) => this.limitDateRange(date));\n        }\n\n        return [this.limitDateRange(now)];\n      }\n\n      if (!defaultDate || Array.isArray(defaultDate)) {\n        defaultDate = now;\n      }\n      return this.limitDateRange(defaultDate);\n    }",
              "scrollIntoView": "scrollIntoView() {\n      requestAnimationFrame(() => {\n        const { currentDate, type, show, poppable, minDate, maxDate } =\n          this.data;\n        if (!currentDate) return;\n        // @ts-ignore\n        const targetDate = type === 'single' ? currentDate : currentDate[0];\n        const displayed = show || !poppable;\n        if (!targetDate || !displayed) {\n          return;\n        }\n\n        const months = getMonths(minDate, maxDate);\n\n        months.some((month, index) => {\n          if (compareMonth(month, targetDate) === 0) {\n            this.setData({ scrollIntoView: `month${index}` });\n            return true;\n          }\n\n          return false;\n        });\n      });\n    }",
              "onOpen": "onOpen() {\n      this.$emit('open');\n    }",
              "onOpened": "onOpened() {\n      this.$emit('opened');\n    }",
              "onClose": "onClose() {\n      this.$emit('close');\n    }",
              "onClosed": "onClosed() {\n      this.$emit('closed');\n    }",
              "onClickDay": "onClickDay(event) {\n      if (this.data.readonly) {\n        return;\n      }\n\n      let { date } = event.detail;\n      const { type, currentDate, allowSameDay } = this.data;\n\n      if (type === 'range') {\n        // @ts-ignore\n        const [startDay, endDay] = currentDate;\n\n        if (startDay && !endDay) {\n          const compareToStart = compareDay(date, startDay);\n\n          if (compareToStart === 1) {\n            const { days } = this.selectComponent('.month').data;\n            days.some((day: Day, index) => {\n              const isDisabled =\n                day.type === 'disabled' &&\n                getTime(startDay) < getTime(day.date) &&\n                getTime(day.date) < getTime(date);\n              if (isDisabled) {\n                ({ date } = days[index - 1]);\n              }\n              return isDisabled;\n            });\n            this.select([startDay, date], true);\n          } else if (compareToStart === -1) {\n            this.select([date, null]);\n          } else if (allowSameDay) {\n            this.select([date, date], true);\n          }\n        } else {\n          this.select([date, null]);\n        }\n      } else if (type === 'multiple') {\n        let selectedIndex: number;\n\n        // @ts-ignore\n        const selected = currentDate.some((dateItem: number, index: number) => {\n          const equal = compareDay(dateItem, date) === 0;\n          if (equal) {\n            selectedIndex = index;\n          }\n          return equal;\n        });\n\n        if (selected) {\n          // @ts-ignore\n          const cancelDate = currentDate.splice(selectedIndex, 1);\n          this.setData({ currentDate });\n          this.unselect(cancelDate);\n        } else {\n          // @ts-ignore\n          this.select([...currentDate, date]);\n        }\n      } else {\n        this.select(date, true);\n      }\n    }",
              "unselect": "unselect(dateArray) {\n      const date = dateArray[0];\n      if (date) {\n        this.$emit('unselect', copyDates(date));\n      }\n    }",
              "select": "select(date, complete?: boolean) {\n      if (complete && this.data.type === 'range') {\n        const valid = this.checkRange(date);\n\n        if (!valid) {\n          // auto selected to max range if showConfirm\n          if (this.data.showConfirm) {\n            this.emit([\n              date[0],\n              getDayByOffset(date[0], this.data.maxRange - 1),\n            ]);\n          } else {\n            this.emit(date);\n          }\n          return;\n        }\n      }\n\n      this.emit(date);\n\n      if (complete && !this.data.showConfirm) {\n        this.onConfirm();\n      }\n    }",
              "emit": "emit(date) {\n      this.setData({\n        currentDate: Array.isArray(date) ? date.map(getTime) : getTime(date),\n      });\n      this.$emit('select', copyDates(date));\n    }",
              "checkRange": "checkRange(date) {\n      const { maxRange, rangePrompt, showRangePrompt } = this.data;\n\n      if (maxRange && calcDateNum(date) > maxRange) {\n        if (showRangePrompt) {\n          Toast({\n            context: this,\n            message: rangePrompt || `选择天数不能超过 ${maxRange} 天`,\n          });\n        }\n        this.$emit('over-range');\n\n        return false;\n      }\n\n      return true;\n    }",
              "onConfirm": "onConfirm() {\n      if (\n        this.data.type === 'range' &&\n        !this.checkRange(this.data.currentDate)\n      ) {\n        return;\n      }\n      wx.nextTick(() => {\n        // @ts-ignore\n        this.$emit('confirm', copyDates(this.data.currentDate));\n      });\n    }",
              "onClickSubtitle": "onClickSubtitle(event: WechatMiniprogram.TouchEvent) {\n      this.$emit('click-subtitle', event);\n    }"
            }
          }
        ]
      }
    ]
  },
  "wxs": {
    "kind": "SourceFile",
    "text": "var utils = require('./utils.wxs');\n\nfunction getMonths(minDate, maxDate) {\n  var months = [];\n  var cursor = getDate(minDate);\n\n  cursor.setDate(1);\n\n  do {\n    months.push(cursor.getTime());\n    cursor.setMonth(cursor.getMonth() + 1);\n  } while (utils.compareMonth(cursor, getDate(maxDate)) !== 1);\n\n  return months;\n}\n\nfunction getButtonDisabled(type, currentDate, minRange) {\n  if (currentDate == null) {\n    return true;\n  }\n\n  if (type === 'range') {\n    return !currentDate[0] || !currentDate[1];\n  }\n\n  if (type === 'multiple') {\n    return currentDate.length < minRange;\n  }\n\n  return !currentDate;\n}\n\nmodule.exports = {\n  getMonths: getMonths,\n  getButtonDisabled: getButtonDisabled\n};\n",
    "statements": [
      {
        "kind": "FirstStatement",
        "text": "var utils = require('./utils.wxs');"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function getMonths(minDate, maxDate) {\n  var months = [];\n  var cursor = getDate(minDate);\n\n  cursor.setDate(1);\n\n  do {\n    months.push(cursor.getTime());\n    cursor.setMonth(cursor.getMonth() + 1);\n  } while (utils.compareMonth(cursor, getDate(maxDate)) !== 1);\n\n  return months;\n}",
        "name": "getMonths"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function getButtonDisabled(type, currentDate, minRange) {\n  if (currentDate == null) {\n    return true;\n  }\n\n  if (type === 'range') {\n    return !currentDate[0] || !currentDate[1];\n  }\n\n  if (type === 'multiple') {\n    return currentDate.length < minRange;\n  }\n\n  return !currentDate;\n}",
        "name": "getButtonDisabled"
      },
      {
        "kind": "ExpressionStatement",
        "text": "module.exports = {\n  getMonths: getMonths,\n  getButtonDisabled: getButtonDisabled\n};",
        "expression": "module.exports = {\n  getMonths: getMonths,\n  getButtonDisabled: getButtonDisabled\n}"
      }
    ]
  },
  "wxss": ".van-calendar{background-color:var(--calendar-background-color,#fff);display:flex;flex-direction:column;height:var(--calendar-height,100%)}.van-calendar__close-icon{top:11px}.van-calendar__popup--bottom,.van-calendar__popup--top{height:var(--calendar-popup-height,90%)}.van-calendar__popup--left,.van-calendar__popup--right{height:100%}.van-calendar__body{-webkit-overflow-scrolling:touch;flex:1;overflow:auto}.van-calendar__footer{flex-shrink:0;padding:0 var(--padding-md,16px)}.van-calendar__footer--safe-area-inset-bottom{padding-bottom:env(safe-area-inset-bottom)}.van-calendar__footer+.van-calendar__footer,.van-calendar__footer:empty{display:none}.van-calendar__footer:empty+.van-calendar__footer{display:block!important}.van-calendar__confirm{height:var(--calendar-confirm-button-height,36px)!important;line-height:var(--calendar-confirm-button-line-height,34px)!important;margin:var(--calendar-confirm-button-margin,7px 0)!important}"
}