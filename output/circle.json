{
  "wxml": [
    {
      "tag": "div",
      "attrs": {
        "class": "van-circle"
      },
      "children": [
        {
          "tag": "canvas",
          "attrs": {
            "class": "van-circle__canvas",
            ":type": "type",
            "style": "width: {{ utils.addUnit(size) }};height:{{ utils.addUnit(size) }}",
            "id": "van-circle",
            "canvas-id": "van-circle"
          }
        },
        {
          "tag": "div",
          "attrs": {
            "v-if": "!text",
            "class": "van-circle__text"
          },
          "children": [
            {
              "tag": "slot"
            }
          ]
        },
        {
          "tag": "cover-view",
          "attrs": {
            "v-else": "",
            "class": "van-circle__text"
          }
        }
      ]
    }
  ],
  "ts": {
    "kind": "SourceFile",
    "text": "import { BLUE, WHITE } from '../common/color';\nimport { VantComponent } from '../common/component';\nimport { getSystemInfoSync } from '../common/utils';\nimport { isObj } from '../common/validator';\nimport { canIUseCanvas2d } from '../common/version';\nimport { adaptor } from './canvas';\n\nfunction format(rate) {\n  return Math.min(Math.max(rate, 0), 100);\n}\nconst PERIMETER = 2 * Math.PI;\nconst BEGIN_ANGLE = -Math.PI / 2;\nconst STEP = 1;\n\nVantComponent({\n  props: {\n    text: String,\n    lineCap: {\n      type: String,\n      value: 'round',\n    },\n    value: {\n      type: Number,\n      value: 0,\n      observer: 'reRender',\n    },\n    speed: {\n      type: Number,\n      value: 50,\n    },\n    size: {\n      type: Number,\n      value: 100,\n      observer() {\n        this.drawCircle(this.currentValue);\n      },\n    },\n    fill: String,\n    layerColor: {\n      type: String,\n      value: WHITE,\n    },\n    color: {\n      type: null,\n      value: BLUE,\n      observer() {\n        this.setHoverColor().then(() => {\n          this.drawCircle(this.currentValue);\n        });\n      },\n    },\n    type: {\n      type: String,\n      value: '',\n    },\n    strokeWidth: {\n      type: Number,\n      value: 4,\n    },\n    clockwise: {\n      type: Boolean,\n      value: true,\n    },\n  },\n\n  data: {\n    hoverColor: BLUE,\n  },\n\n  methods: {\n    getContext(): Promise<WechatMiniprogram.CanvasContext> {\n      const { type, size } = this.data;\n\n      if (type === '' || !canIUseCanvas2d()) {\n        const ctx = wx.createCanvasContext('van-circle', this);\n        return Promise.resolve(ctx);\n      }\n\n      const dpr = getSystemInfoSync().pixelRatio;\n\n      return new Promise((resolve) => {\n        wx.createSelectorQuery()\n          .in(this)\n          .select('#van-circle')\n          .node()\n          .exec((res) => {\n            const canvas = res[0].node;\n            const ctx = canvas.getContext(type);\n\n            if (!this.inited) {\n              this.inited = true;\n              canvas.width = size * dpr;\n              canvas.height = size * dpr;\n              ctx.scale(dpr, dpr);\n            }\n\n            resolve(adaptor(ctx));\n          });\n      });\n    },\n\n    setHoverColor() {\n      const { color, size } = this.data;\n\n      if (isObj(color)) {\n        return this.getContext().then((context) => {\n          if (!context) return;\n\n          const LinearColor = context.createLinearGradient(size, 0, 0, 0);\n          Object.keys(color)\n            .sort((a, b) => parseFloat(a) - parseFloat(b))\n            .map((key) =>\n              LinearColor.addColorStop(\n                parseFloat(key) / 100,\n                color[key] as string\n              )\n            );\n          this.hoverColor = LinearColor;\n        });\n      }\n\n      this.hoverColor = color;\n      return Promise.resolve();\n    },\n\n    presetCanvas(context, strokeStyle, beginAngle, endAngle, fill?: string) {\n      const { strokeWidth, lineCap, clockwise, size } = this.data;\n      const position = size / 2;\n      const radius = position - strokeWidth / 2;\n\n      context.setStrokeStyle(strokeStyle);\n      context.setLineWidth(strokeWidth);\n      context.setLineCap(lineCap);\n\n      context.beginPath();\n      context.arc(position, position, radius, beginAngle, endAngle, !clockwise);\n      context.stroke();\n\n      if (fill) {\n        context.setFillStyle(fill);\n        context.fill();\n      }\n    },\n\n    renderLayerCircle(context) {\n      const { layerColor, fill } = this.data;\n      this.presetCanvas(context, layerColor, 0, PERIMETER, fill);\n    },\n\n    renderHoverCircle(context, formatValue) {\n      const { clockwise } = this.data;\n      // 结束角度\n      const progress = PERIMETER * (formatValue / 100);\n      const endAngle = clockwise\n        ? BEGIN_ANGLE + progress\n        : 3 * Math.PI - (BEGIN_ANGLE + progress);\n\n      this.presetCanvas(context, this.hoverColor, BEGIN_ANGLE, endAngle);\n    },\n\n    drawCircle(currentValue) {\n      const { size } = this.data;\n\n      this.getContext().then((context) => {\n        if (!context) return;\n\n        context.clearRect(0, 0, size, size);\n        this.renderLayerCircle(context);\n\n        const formatValue = format(currentValue);\n        if (formatValue !== 0) {\n          this.renderHoverCircle(context, formatValue);\n        }\n\n        context.draw();\n      });\n    },\n\n    reRender() {\n      // tofector 动画暂时没有想到好的解决方案\n      const { value, speed } = this.data;\n\n      if (speed <= 0 || speed > 1000) {\n        this.drawCircle(value);\n        return;\n      }\n\n      this.clearMockInterval();\n      this.currentValue = this.currentValue || 0;\n      const run = () => {\n        this.interval = setTimeout(() => {\n          if (this.currentValue !== value) {\n            if (Math.abs(this.currentValue - value) < STEP) {\n              this.currentValue = value;\n            } else if (this.currentValue < value) {\n              this.currentValue += STEP;\n            } else {\n              this.currentValue -= STEP;\n            }\n            this.drawCircle(this.currentValue);\n            run();\n          } else {\n            this.clearMockInterval();\n          }\n        }, 1000 / speed);\n      };\n      run();\n    },\n\n    clearMockInterval() {\n      if (this.interval) {\n        clearTimeout(this.interval);\n        this.interval = null;\n      }\n    },\n  },\n\n  mounted() {\n    this.currentValue = this.data.value;\n\n    this.setHoverColor().then(() => {\n      this.drawCircle(this.currentValue);\n    });\n  },\n\n  destroyed() {\n    this.clearMockInterval();\n  },\n});\n",
    "statements": [
      {
        "kind": "ImportDeclaration",
        "text": "import { BLUE, WHITE } from '../common/color';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { VantComponent } from '../common/component';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { getSystemInfoSync } from '../common/utils';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { isObj } from '../common/validator';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { canIUseCanvas2d } from '../common/version';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { adaptor } from './canvas';"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function format(rate) {\n  return Math.min(Math.max(rate, 0), 100);\n}",
        "name": "format"
      },
      {
        "kind": "FirstStatement",
        "text": "const PERIMETER = 2 * Math.PI;"
      },
      {
        "kind": "FirstStatement",
        "text": "const BEGIN_ANGLE = -Math.PI / 2;"
      },
      {
        "kind": "FirstStatement",
        "text": "const STEP = 1;"
      },
      {
        "kind": "ExpressionStatement",
        "text": "VantComponent({\n  props: {\n    text: String,\n    lineCap: {\n      type: String,\n      value: 'round',\n    },\n    value: {\n      type: Number,\n      value: 0,\n      observer: 'reRender',\n    },\n    speed: {\n      type: Number,\n      value: 50,\n    },\n    size: {\n      type: Number,\n      value: 100,\n      observer() {\n        this.drawCircle(this.currentValue);\n      },\n    },\n    fill: String,\n    layerColor: {\n      type: String,\n      value: WHITE,\n    },\n    color: {\n      type: null,\n      value: BLUE,\n      observer() {\n        this.setHoverColor().then(() => {\n          this.drawCircle(this.currentValue);\n        });\n      },\n    },\n    type: {\n      type: String,\n      value: '',\n    },\n    strokeWidth: {\n      type: Number,\n      value: 4,\n    },\n    clockwise: {\n      type: Boolean,\n      value: true,\n    },\n  },\n\n  data: {\n    hoverColor: BLUE,\n  },\n\n  methods: {\n    getContext(): Promise<WechatMiniprogram.CanvasContext> {\n      const { type, size } = this.data;\n\n      if (type === '' || !canIUseCanvas2d()) {\n        const ctx = wx.createCanvasContext('van-circle', this);\n        return Promise.resolve(ctx);\n      }\n\n      const dpr = getSystemInfoSync().pixelRatio;\n\n      return new Promise((resolve) => {\n        wx.createSelectorQuery()\n          .in(this)\n          .select('#van-circle')\n          .node()\n          .exec((res) => {\n            const canvas = res[0].node;\n            const ctx = canvas.getContext(type);\n\n            if (!this.inited) {\n              this.inited = true;\n              canvas.width = size * dpr;\n              canvas.height = size * dpr;\n              ctx.scale(dpr, dpr);\n            }\n\n            resolve(adaptor(ctx));\n          });\n      });\n    },\n\n    setHoverColor() {\n      const { color, size } = this.data;\n\n      if (isObj(color)) {\n        return this.getContext().then((context) => {\n          if (!context) return;\n\n          const LinearColor = context.createLinearGradient(size, 0, 0, 0);\n          Object.keys(color)\n            .sort((a, b) => parseFloat(a) - parseFloat(b))\n            .map((key) =>\n              LinearColor.addColorStop(\n                parseFloat(key) / 100,\n                color[key] as string\n              )\n            );\n          this.hoverColor = LinearColor;\n        });\n      }\n\n      this.hoverColor = color;\n      return Promise.resolve();\n    },\n\n    presetCanvas(context, strokeStyle, beginAngle, endAngle, fill?: string) {\n      const { strokeWidth, lineCap, clockwise, size } = this.data;\n      const position = size / 2;\n      const radius = position - strokeWidth / 2;\n\n      context.setStrokeStyle(strokeStyle);\n      context.setLineWidth(strokeWidth);\n      context.setLineCap(lineCap);\n\n      context.beginPath();\n      context.arc(position, position, radius, beginAngle, endAngle, !clockwise);\n      context.stroke();\n\n      if (fill) {\n        context.setFillStyle(fill);\n        context.fill();\n      }\n    },\n\n    renderLayerCircle(context) {\n      const { layerColor, fill } = this.data;\n      this.presetCanvas(context, layerColor, 0, PERIMETER, fill);\n    },\n\n    renderHoverCircle(context, formatValue) {\n      const { clockwise } = this.data;\n      // 结束角度\n      const progress = PERIMETER * (formatValue / 100);\n      const endAngle = clockwise\n        ? BEGIN_ANGLE + progress\n        : 3 * Math.PI - (BEGIN_ANGLE + progress);\n\n      this.presetCanvas(context, this.hoverColor, BEGIN_ANGLE, endAngle);\n    },\n\n    drawCircle(currentValue) {\n      const { size } = this.data;\n\n      this.getContext().then((context) => {\n        if (!context) return;\n\n        context.clearRect(0, 0, size, size);\n        this.renderLayerCircle(context);\n\n        const formatValue = format(currentValue);\n        if (formatValue !== 0) {\n          this.renderHoverCircle(context, formatValue);\n        }\n\n        context.draw();\n      });\n    },\n\n    reRender() {\n      // tofector 动画暂时没有想到好的解决方案\n      const { value, speed } = this.data;\n\n      if (speed <= 0 || speed > 1000) {\n        this.drawCircle(value);\n        return;\n      }\n\n      this.clearMockInterval();\n      this.currentValue = this.currentValue || 0;\n      const run = () => {\n        this.interval = setTimeout(() => {\n          if (this.currentValue !== value) {\n            if (Math.abs(this.currentValue - value) < STEP) {\n              this.currentValue = value;\n            } else if (this.currentValue < value) {\n              this.currentValue += STEP;\n            } else {\n              this.currentValue -= STEP;\n            }\n            this.drawCircle(this.currentValue);\n            run();\n          } else {\n            this.clearMockInterval();\n          }\n        }, 1000 / speed);\n      };\n      run();\n    },\n\n    clearMockInterval() {\n      if (this.interval) {\n        clearTimeout(this.interval);\n        this.interval = null;\n      }\n    },\n  },\n\n  mounted() {\n    this.currentValue = this.data.value;\n\n    this.setHoverColor().then(() => {\n      this.drawCircle(this.currentValue);\n    });\n  },\n\n  destroyed() {\n    this.clearMockInterval();\n  },\n});",
        "expression": "VantComponent({\n  props: {\n    text: String,\n    lineCap: {\n      type: String,\n      value: 'round',\n    },\n    value: {\n      type: Number,\n      value: 0,\n      observer: 'reRender',\n    },\n    speed: {\n      type: Number,\n      value: 50,\n    },\n    size: {\n      type: Number,\n      value: 100,\n      observer() {\n        this.drawCircle(this.currentValue);\n      },\n    },\n    fill: String,\n    layerColor: {\n      type: String,\n      value: WHITE,\n    },\n    color: {\n      type: null,\n      value: BLUE,\n      observer() {\n        this.setHoverColor().then(() => {\n          this.drawCircle(this.currentValue);\n        });\n      },\n    },\n    type: {\n      type: String,\n      value: '',\n    },\n    strokeWidth: {\n      type: Number,\n      value: 4,\n    },\n    clockwise: {\n      type: Boolean,\n      value: true,\n    },\n  },\n\n  data: {\n    hoverColor: BLUE,\n  },\n\n  methods: {\n    getContext(): Promise<WechatMiniprogram.CanvasContext> {\n      const { type, size } = this.data;\n\n      if (type === '' || !canIUseCanvas2d()) {\n        const ctx = wx.createCanvasContext('van-circle', this);\n        return Promise.resolve(ctx);\n      }\n\n      const dpr = getSystemInfoSync().pixelRatio;\n\n      return new Promise((resolve) => {\n        wx.createSelectorQuery()\n          .in(this)\n          .select('#van-circle')\n          .node()\n          .exec((res) => {\n            const canvas = res[0].node;\n            const ctx = canvas.getContext(type);\n\n            if (!this.inited) {\n              this.inited = true;\n              canvas.width = size * dpr;\n              canvas.height = size * dpr;\n              ctx.scale(dpr, dpr);\n            }\n\n            resolve(adaptor(ctx));\n          });\n      });\n    },\n\n    setHoverColor() {\n      const { color, size } = this.data;\n\n      if (isObj(color)) {\n        return this.getContext().then((context) => {\n          if (!context) return;\n\n          const LinearColor = context.createLinearGradient(size, 0, 0, 0);\n          Object.keys(color)\n            .sort((a, b) => parseFloat(a) - parseFloat(b))\n            .map((key) =>\n              LinearColor.addColorStop(\n                parseFloat(key) / 100,\n                color[key] as string\n              )\n            );\n          this.hoverColor = LinearColor;\n        });\n      }\n\n      this.hoverColor = color;\n      return Promise.resolve();\n    },\n\n    presetCanvas(context, strokeStyle, beginAngle, endAngle, fill?: string) {\n      const { strokeWidth, lineCap, clockwise, size } = this.data;\n      const position = size / 2;\n      const radius = position - strokeWidth / 2;\n\n      context.setStrokeStyle(strokeStyle);\n      context.setLineWidth(strokeWidth);\n      context.setLineCap(lineCap);\n\n      context.beginPath();\n      context.arc(position, position, radius, beginAngle, endAngle, !clockwise);\n      context.stroke();\n\n      if (fill) {\n        context.setFillStyle(fill);\n        context.fill();\n      }\n    },\n\n    renderLayerCircle(context) {\n      const { layerColor, fill } = this.data;\n      this.presetCanvas(context, layerColor, 0, PERIMETER, fill);\n    },\n\n    renderHoverCircle(context, formatValue) {\n      const { clockwise } = this.data;\n      // 结束角度\n      const progress = PERIMETER * (formatValue / 100);\n      const endAngle = clockwise\n        ? BEGIN_ANGLE + progress\n        : 3 * Math.PI - (BEGIN_ANGLE + progress);\n\n      this.presetCanvas(context, this.hoverColor, BEGIN_ANGLE, endAngle);\n    },\n\n    drawCircle(currentValue) {\n      const { size } = this.data;\n\n      this.getContext().then((context) => {\n        if (!context) return;\n\n        context.clearRect(0, 0, size, size);\n        this.renderLayerCircle(context);\n\n        const formatValue = format(currentValue);\n        if (formatValue !== 0) {\n          this.renderHoverCircle(context, formatValue);\n        }\n\n        context.draw();\n      });\n    },\n\n    reRender() {\n      // tofector 动画暂时没有想到好的解决方案\n      const { value, speed } = this.data;\n\n      if (speed <= 0 || speed > 1000) {\n        this.drawCircle(value);\n        return;\n      }\n\n      this.clearMockInterval();\n      this.currentValue = this.currentValue || 0;\n      const run = () => {\n        this.interval = setTimeout(() => {\n          if (this.currentValue !== value) {\n            if (Math.abs(this.currentValue - value) < STEP) {\n              this.currentValue = value;\n            } else if (this.currentValue < value) {\n              this.currentValue += STEP;\n            } else {\n              this.currentValue -= STEP;\n            }\n            this.drawCircle(this.currentValue);\n            run();\n          } else {\n            this.clearMockInterval();\n          }\n        }, 1000 / speed);\n      };\n      run();\n    },\n\n    clearMockInterval() {\n      if (this.interval) {\n        clearTimeout(this.interval);\n        this.interval = null;\n      }\n    },\n  },\n\n  mounted() {\n    this.currentValue = this.data.value;\n\n    this.setHoverColor().then(() => {\n      this.drawCircle(this.currentValue);\n    });\n  },\n\n  destroyed() {\n    this.clearMockInterval();\n  },\n})",
        "callee": "VantComponent",
        "arguments": [
          {
            "props": {
              "text": "String",
              "lineCap": {
                "type": "String",
                "value": "round"
              },
              "value": {
                "type": "Number",
                "value": "0",
                "observer": "reRender"
              },
              "speed": {
                "type": "Number",
                "value": "50"
              },
              "size": {
                "type": "Number",
                "value": "100"
              },
              "fill": "String",
              "layerColor": {
                "type": "String",
                "value": "WHITE"
              },
              "color": {
                "type": "null",
                "value": "BLUE"
              },
              "type": {
                "type": "String",
                "value": ""
              },
              "strokeWidth": {
                "type": "Number",
                "value": "4"
              },
              "clockwise": {
                "type": "Boolean",
                "value": "true"
              }
            },
            "data": {
              "hoverColor": "BLUE"
            },
            "methods": {
              "getContext": "getContext(): Promise<WechatMiniprogram.CanvasContext> {\n      const { type, size } = this.data;\n\n      if (type === '' || !canIUseCanvas2d()) {\n        const ctx = wx.createCanvasContext('van-circle', this);\n        return Promise.resolve(ctx);\n      }\n\n      const dpr = getSystemInfoSync().pixelRatio;\n\n      return new Promise((resolve) => {\n        wx.createSelectorQuery()\n          .in(this)\n          .select('#van-circle')\n          .node()\n          .exec((res) => {\n            const canvas = res[0].node;\n            const ctx = canvas.getContext(type);\n\n            if (!this.inited) {\n              this.inited = true;\n              canvas.width = size * dpr;\n              canvas.height = size * dpr;\n              ctx.scale(dpr, dpr);\n            }\n\n            resolve(adaptor(ctx));\n          });\n      });\n    }",
              "setHoverColor": "setHoverColor() {\n      const { color, size } = this.data;\n\n      if (isObj(color)) {\n        return this.getContext().then((context) => {\n          if (!context) return;\n\n          const LinearColor = context.createLinearGradient(size, 0, 0, 0);\n          Object.keys(color)\n            .sort((a, b) => parseFloat(a) - parseFloat(b))\n            .map((key) =>\n              LinearColor.addColorStop(\n                parseFloat(key) / 100,\n                color[key] as string\n              )\n            );\n          this.hoverColor = LinearColor;\n        });\n      }\n\n      this.hoverColor = color;\n      return Promise.resolve();\n    }",
              "presetCanvas": "presetCanvas(context, strokeStyle, beginAngle, endAngle, fill?: string) {\n      const { strokeWidth, lineCap, clockwise, size } = this.data;\n      const position = size / 2;\n      const radius = position - strokeWidth / 2;\n\n      context.setStrokeStyle(strokeStyle);\n      context.setLineWidth(strokeWidth);\n      context.setLineCap(lineCap);\n\n      context.beginPath();\n      context.arc(position, position, radius, beginAngle, endAngle, !clockwise);\n      context.stroke();\n\n      if (fill) {\n        context.setFillStyle(fill);\n        context.fill();\n      }\n    }",
              "renderLayerCircle": "renderLayerCircle(context) {\n      const { layerColor, fill } = this.data;\n      this.presetCanvas(context, layerColor, 0, PERIMETER, fill);\n    }",
              "renderHoverCircle": "renderHoverCircle(context, formatValue) {\n      const { clockwise } = this.data;\n      // 结束角度\n      const progress = PERIMETER * (formatValue / 100);\n      const endAngle = clockwise\n        ? BEGIN_ANGLE + progress\n        : 3 * Math.PI - (BEGIN_ANGLE + progress);\n\n      this.presetCanvas(context, this.hoverColor, BEGIN_ANGLE, endAngle);\n    }",
              "drawCircle": "drawCircle(currentValue) {\n      const { size } = this.data;\n\n      this.getContext().then((context) => {\n        if (!context) return;\n\n        context.clearRect(0, 0, size, size);\n        this.renderLayerCircle(context);\n\n        const formatValue = format(currentValue);\n        if (formatValue !== 0) {\n          this.renderHoverCircle(context, formatValue);\n        }\n\n        context.draw();\n      });\n    }",
              "reRender": "reRender() {\n      // tofector 动画暂时没有想到好的解决方案\n      const { value, speed } = this.data;\n\n      if (speed <= 0 || speed > 1000) {\n        this.drawCircle(value);\n        return;\n      }\n\n      this.clearMockInterval();\n      this.currentValue = this.currentValue || 0;\n      const run = () => {\n        this.interval = setTimeout(() => {\n          if (this.currentValue !== value) {\n            if (Math.abs(this.currentValue - value) < STEP) {\n              this.currentValue = value;\n            } else if (this.currentValue < value) {\n              this.currentValue += STEP;\n            } else {\n              this.currentValue -= STEP;\n            }\n            this.drawCircle(this.currentValue);\n            run();\n          } else {\n            this.clearMockInterval();\n          }\n        }, 1000 / speed);\n      };\n      run();\n    }",
              "clearMockInterval": "clearMockInterval() {\n      if (this.interval) {\n        clearTimeout(this.interval);\n        this.interval = null;\n      }\n    }"
            }
          }
        ]
      }
    ]
  },
  "wxs": null,
  "wxss": ".van-circle{display:inline-block;position:relative;text-align:center}.van-circle__text{color:var(--circle-text-color,#323233);left:0;position:absolute;top:50%;transform:translateY(-50%);width:100%}"
}