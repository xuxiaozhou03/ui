{
  "wxml": [
    {
      "tag": "van-picker",
      "attrs": {
        "class": "van-datetime-picker",
        ":active-class": "cn( activeClass)",
        ":toolbar-class": "cn( toolbarClass)",
        ":column-class": "cn( columnClass)",
        ":title": "title",
        ":columns": "columns",
        ":item-height": "itemHeight",
        ":show-toolbar": "showToolbar",
        ":visible-item-count": "visibleItemCount",
        ":confirm-button-text": "confirmButtonText",
        ":cancel-button-text": "cancelButtonText",
        "@change": "onChange",
        "@confirm": "onConfirm",
        "@cancel": "onCancel"
      }
    }
  ],
  "ts": {
    "kind": "SourceFile",
    "text": "import { VantComponent } from '../common/component';\nimport { isDef } from '../common/validator';\nimport { pickerProps } from '../picker/shared';\n\nconst currentYear = new Date().getFullYear();\n\nfunction isValidDate(date: number) {\n  return isDef(date) && !isNaN(new Date(date).getTime());\n}\n\nfunction range(num: number, min: number, max: number) {\n  return Math.min(Math.max(num, min), max);\n}\n\nfunction padZero(val: string | number) {\n  return `00${val}`.slice(-2);\n}\n\nfunction times(n: number, iteratee: (index: number) => string): string[] {\n  let index = -1;\n  const result = Array(n < 0 ? 0 : n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nfunction getTrueValue(formattedValue: string) {\n  if (formattedValue === undefined) {\n    formattedValue = '1';\n  }\n  while (isNaN(parseInt(formattedValue, 10))) {\n    formattedValue = formattedValue.slice(1);\n  }\n  return parseInt(formattedValue, 10);\n}\n\nfunction getMonthEndDay(year: number, month: number): number {\n  return 32 - new Date(year, month - 1, 32).getDate();\n}\n\nconst defaultFormatter = (\n  type: 'year' | 'month' | 'day' | 'hour' | 'minute',\n  value: string\n) => value;\n\nVantComponent({\n  classes: ['active-class', 'toolbar-class', 'column-class'],\n\n  props: {\n    ...pickerProps,\n    value: {\n      type: null,\n      observer: 'updateValue',\n    },\n    filter: null,\n    type: {\n      type: String,\n      value: 'datetime',\n      observer: 'updateValue',\n    },\n    showToolbar: {\n      type: Boolean,\n      value: true,\n    },\n    formatter: {\n      type: null,\n      value: defaultFormatter,\n    },\n    minDate: {\n      type: Number,\n      value: new Date(currentYear - 10, 0, 1).getTime(),\n      observer: 'updateValue',\n    },\n    maxDate: {\n      type: Number,\n      value: new Date(currentYear + 10, 11, 31).getTime(),\n      observer: 'updateValue',\n    },\n    minHour: {\n      type: Number,\n      value: 0,\n      observer: 'updateValue',\n    },\n    maxHour: {\n      type: Number,\n      value: 23,\n      observer: 'updateValue',\n    },\n    minMinute: {\n      type: Number,\n      value: 0,\n      observer: 'updateValue',\n    },\n    maxMinute: {\n      type: Number,\n      value: 59,\n      observer: 'updateValue',\n    },\n  },\n\n  data: {\n    innerValue: Date.now(),\n    columns: [],\n  },\n\n  methods: {\n    updateValue() {\n      const { data } = this;\n      const val = this.correctValue(data.value);\n      const isEqual = val === data.innerValue;\n      this.updateColumnValue(val).then(() => {\n        if (!isEqual) {\n          this.$emit('input', val);\n        }\n      });\n    },\n\n    getPicker() {\n      if (this.picker == null) {\n        this.picker = this.selectComponent('.van-datetime-picker');\n\n        const { picker } = this;\n        const { setColumnValues } = picker;\n        picker.setColumnValues = (...args: any) =>\n          setColumnValues.apply(picker, [...args, false]);\n      }\n\n      return this.picker;\n    },\n\n    updateColumns() {\n      const { formatter = defaultFormatter } = this.data;\n      const results = this.getOriginColumns().map((column) => ({\n        values: column.values.map((value) => formatter(column.type, value)),\n      }));\n\n      return this.set({ columns: results });\n    },\n\n    getOriginColumns() {\n      const { filter } = this.data;\n      const results = this.getRanges().map(({ type, range }) => {\n        let values = times(range[1] - range[0] + 1, (index) => {\n          const value = range[0] + index;\n          return type === 'year' ? `${value}` : padZero(value);\n        });\n\n        if (filter) {\n          values = filter(type, values);\n        }\n\n        return { type, values };\n      });\n\n      return results;\n    },\n\n    getRanges() {\n      const { data } = this;\n      if (data.type === 'time') {\n        return [\n          {\n            type: 'hour',\n            range: [data.minHour, data.maxHour],\n          },\n          {\n            type: 'minute',\n            range: [data.minMinute, data.maxMinute],\n          },\n        ];\n      }\n\n      const {\n        maxYear,\n        maxDate,\n        maxMonth,\n        maxHour,\n        maxMinute,\n      } = this.getBoundary('max', data.innerValue);\n      const {\n        minYear,\n        minDate,\n        minMonth,\n        minHour,\n        minMinute,\n      } = this.getBoundary('min', data.innerValue);\n\n      const result = [\n        {\n          type: 'year',\n          range: [minYear, maxYear],\n        },\n        {\n          type: 'month',\n          range: [minMonth, maxMonth],\n        },\n        {\n          type: 'day',\n          range: [minDate, maxDate],\n        },\n        {\n          type: 'hour',\n          range: [minHour, maxHour],\n        },\n        {\n          type: 'minute',\n          range: [minMinute, maxMinute],\n        },\n      ];\n\n      if (data.type === 'date') result.splice(3, 2);\n      if (data.type === 'year-month') result.splice(2, 3);\n      return result;\n    },\n\n    correctValue(value: any) {\n      const { data } = this;\n      // validate value\n      const isDateType = data.type !== 'time';\n      if (isDateType && !isValidDate(value)) {\n        value = data.minDate;\n      } else if (!isDateType && !value) {\n        const { minHour } = data;\n        value = `${padZero(minHour)}:00`;\n      }\n\n      // time type\n      if (!isDateType) {\n        let [hour, minute] = value.split(':');\n        hour = padZero(range(hour, data.minHour, data.maxHour));\n        minute = padZero(range(minute, data.minMinute, data.maxMinute));\n\n        return `${hour}:${minute}`;\n      }\n\n      // date type\n      value = Math.max(value, data.minDate);\n      value = Math.min(value, data.maxDate);\n\n      return value;\n    },\n\n    getBoundary(type: string, innerValue: number) {\n      const value = new Date(innerValue);\n      const boundary = new Date(this.data[`${type}Date`]);\n      const year = boundary.getFullYear();\n      let month = 1;\n      let date = 1;\n      let hour = 0;\n      let minute = 0;\n\n      if (type === 'max') {\n        month = 12;\n        date = getMonthEndDay(value.getFullYear(), value.getMonth() + 1);\n        hour = 23;\n        minute = 59;\n      }\n\n      if (value.getFullYear() === year) {\n        month = boundary.getMonth() + 1;\n        if (value.getMonth() + 1 === month) {\n          date = boundary.getDate();\n          if (value.getDate() === date) {\n            hour = boundary.getHours();\n            if (value.getHours() === hour) {\n              minute = boundary.getMinutes();\n            }\n          }\n        }\n      }\n\n      return {\n        [`${type}Year`]: year,\n        [`${type}Month`]: month,\n        [`${type}Date`]: date,\n        [`${type}Hour`]: hour,\n        [`${type}Minute`]: minute,\n      };\n    },\n\n    onCancel() {\n      this.$emit('cancel');\n    },\n\n    onConfirm() {\n      this.$emit('confirm', this.data.innerValue);\n    },\n\n    onChange() {\n      const { data } = this;\n      let value;\n\n      const picker = this.getPicker();\n      const originColumns = this.getOriginColumns();\n\n      if (data.type === 'time') {\n        const indexes = picker.getIndexes();\n        value = `${+originColumns[0].values[indexes[0]]}:${+originColumns[1]\n          .values[indexes[1]]}`;\n      } else {\n        const indexes = picker.getIndexes();\n        const values = indexes.map(\n          (value, index) => originColumns[index].values[value]\n        );\n        const year = getTrueValue(values[0]);\n        const month = getTrueValue(values[1]);\n        const maxDate = getMonthEndDay(year, month);\n        let date = getTrueValue(values[2]);\n        if (data.type === 'year-month') {\n          date = 1;\n        }\n        date = date > maxDate ? maxDate : date;\n        let hour = 0;\n        let minute = 0;\n        if (data.type === 'datetime') {\n          hour = getTrueValue(values[3]);\n          minute = getTrueValue(values[4]);\n        }\n        value = new Date(year, month - 1, date, hour, minute);\n      }\n      value = this.correctValue(value);\n\n      this.updateColumnValue(value).then(() => {\n        this.$emit('input', value);\n        this.$emit('change', picker);\n      });\n    },\n\n    updateColumnValue(value) {\n      let values: string[] = [];\n      const { type } = this.data;\n      const formatter = this.data.formatter || defaultFormatter;\n      const picker = this.getPicker();\n\n      if (type === 'time') {\n        const pair = value.split(':');\n        values = [formatter('hour', pair[0]), formatter('minute', pair[1])];\n      } else {\n        const date = new Date(value);\n        values = [\n          formatter('year', `${date.getFullYear()}`),\n          formatter('month', padZero(date.getMonth() + 1)),\n        ];\n        if (type === 'date') {\n          values.push(formatter('day', padZero(date.getDate())));\n        }\n        if (type === 'datetime') {\n          values.push(\n            formatter('day', padZero(date.getDate())),\n            formatter('hour', padZero(date.getHours())),\n            formatter('minute', padZero(date.getMinutes()))\n          );\n        }\n      }\n\n      return this.set({ innerValue: value })\n        .then(() => this.updateColumns())\n        .then(() => picker.setValues(values));\n    },\n  },\n\n  created() {\n    const innerValue = this.correctValue(this.data.value);\n    this.updateColumnValue(innerValue).then(() => {\n      this.$emit('input', innerValue);\n    });\n  },\n});\n",
    "statements": [
      {
        "kind": "ImportDeclaration",
        "text": "import { VantComponent } from '../common/component';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { isDef } from '../common/validator';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { pickerProps } from '../picker/shared';"
      },
      {
        "kind": "FirstStatement",
        "text": "const currentYear = new Date().getFullYear();"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function isValidDate(date: number) {\n  return isDef(date) && !isNaN(new Date(date).getTime());\n}",
        "name": "isValidDate"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function range(num: number, min: number, max: number) {\n  return Math.min(Math.max(num, min), max);\n}",
        "name": "range"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function padZero(val: string | number) {\n  return `00${val}`.slice(-2);\n}",
        "name": "padZero"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function times(n: number, iteratee: (index: number) => string): string[] {\n  let index = -1;\n  const result = Array(n < 0 ? 0 : n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}",
        "name": "times"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function getTrueValue(formattedValue: string) {\n  if (formattedValue === undefined) {\n    formattedValue = '1';\n  }\n  while (isNaN(parseInt(formattedValue, 10))) {\n    formattedValue = formattedValue.slice(1);\n  }\n  return parseInt(formattedValue, 10);\n}",
        "name": "getTrueValue"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function getMonthEndDay(year: number, month: number): number {\n  return 32 - new Date(year, month - 1, 32).getDate();\n}",
        "name": "getMonthEndDay"
      },
      {
        "kind": "FirstStatement",
        "text": "const defaultFormatter = (\n  type: 'year' | 'month' | 'day' | 'hour' | 'minute',\n  value: string\n) => value;"
      },
      {
        "kind": "ExpressionStatement",
        "text": "VantComponent({\n  classes: ['active-class', 'toolbar-class', 'column-class'],\n\n  props: {\n    ...pickerProps,\n    value: {\n      type: null,\n      observer: 'updateValue',\n    },\n    filter: null,\n    type: {\n      type: String,\n      value: 'datetime',\n      observer: 'updateValue',\n    },\n    showToolbar: {\n      type: Boolean,\n      value: true,\n    },\n    formatter: {\n      type: null,\n      value: defaultFormatter,\n    },\n    minDate: {\n      type: Number,\n      value: new Date(currentYear - 10, 0, 1).getTime(),\n      observer: 'updateValue',\n    },\n    maxDate: {\n      type: Number,\n      value: new Date(currentYear + 10, 11, 31).getTime(),\n      observer: 'updateValue',\n    },\n    minHour: {\n      type: Number,\n      value: 0,\n      observer: 'updateValue',\n    },\n    maxHour: {\n      type: Number,\n      value: 23,\n      observer: 'updateValue',\n    },\n    minMinute: {\n      type: Number,\n      value: 0,\n      observer: 'updateValue',\n    },\n    maxMinute: {\n      type: Number,\n      value: 59,\n      observer: 'updateValue',\n    },\n  },\n\n  data: {\n    innerValue: Date.now(),\n    columns: [],\n  },\n\n  methods: {\n    updateValue() {\n      const { data } = this;\n      const val = this.correctValue(data.value);\n      const isEqual = val === data.innerValue;\n      this.updateColumnValue(val).then(() => {\n        if (!isEqual) {\n          this.$emit('input', val);\n        }\n      });\n    },\n\n    getPicker() {\n      if (this.picker == null) {\n        this.picker = this.selectComponent('.van-datetime-picker');\n\n        const { picker } = this;\n        const { setColumnValues } = picker;\n        picker.setColumnValues = (...args: any) =>\n          setColumnValues.apply(picker, [...args, false]);\n      }\n\n      return this.picker;\n    },\n\n    updateColumns() {\n      const { formatter = defaultFormatter } = this.data;\n      const results = this.getOriginColumns().map((column) => ({\n        values: column.values.map((value) => formatter(column.type, value)),\n      }));\n\n      return this.set({ columns: results });\n    },\n\n    getOriginColumns() {\n      const { filter } = this.data;\n      const results = this.getRanges().map(({ type, range }) => {\n        let values = times(range[1] - range[0] + 1, (index) => {\n          const value = range[0] + index;\n          return type === 'year' ? `${value}` : padZero(value);\n        });\n\n        if (filter) {\n          values = filter(type, values);\n        }\n\n        return { type, values };\n      });\n\n      return results;\n    },\n\n    getRanges() {\n      const { data } = this;\n      if (data.type === 'time') {\n        return [\n          {\n            type: 'hour',\n            range: [data.minHour, data.maxHour],\n          },\n          {\n            type: 'minute',\n            range: [data.minMinute, data.maxMinute],\n          },\n        ];\n      }\n\n      const {\n        maxYear,\n        maxDate,\n        maxMonth,\n        maxHour,\n        maxMinute,\n      } = this.getBoundary('max', data.innerValue);\n      const {\n        minYear,\n        minDate,\n        minMonth,\n        minHour,\n        minMinute,\n      } = this.getBoundary('min', data.innerValue);\n\n      const result = [\n        {\n          type: 'year',\n          range: [minYear, maxYear],\n        },\n        {\n          type: 'month',\n          range: [minMonth, maxMonth],\n        },\n        {\n          type: 'day',\n          range: [minDate, maxDate],\n        },\n        {\n          type: 'hour',\n          range: [minHour, maxHour],\n        },\n        {\n          type: 'minute',\n          range: [minMinute, maxMinute],\n        },\n      ];\n\n      if (data.type === 'date') result.splice(3, 2);\n      if (data.type === 'year-month') result.splice(2, 3);\n      return result;\n    },\n\n    correctValue(value: any) {\n      const { data } = this;\n      // validate value\n      const isDateType = data.type !== 'time';\n      if (isDateType && !isValidDate(value)) {\n        value = data.minDate;\n      } else if (!isDateType && !value) {\n        const { minHour } = data;\n        value = `${padZero(minHour)}:00`;\n      }\n\n      // time type\n      if (!isDateType) {\n        let [hour, minute] = value.split(':');\n        hour = padZero(range(hour, data.minHour, data.maxHour));\n        minute = padZero(range(minute, data.minMinute, data.maxMinute));\n\n        return `${hour}:${minute}`;\n      }\n\n      // date type\n      value = Math.max(value, data.minDate);\n      value = Math.min(value, data.maxDate);\n\n      return value;\n    },\n\n    getBoundary(type: string, innerValue: number) {\n      const value = new Date(innerValue);\n      const boundary = new Date(this.data[`${type}Date`]);\n      const year = boundary.getFullYear();\n      let month = 1;\n      let date = 1;\n      let hour = 0;\n      let minute = 0;\n\n      if (type === 'max') {\n        month = 12;\n        date = getMonthEndDay(value.getFullYear(), value.getMonth() + 1);\n        hour = 23;\n        minute = 59;\n      }\n\n      if (value.getFullYear() === year) {\n        month = boundary.getMonth() + 1;\n        if (value.getMonth() + 1 === month) {\n          date = boundary.getDate();\n          if (value.getDate() === date) {\n            hour = boundary.getHours();\n            if (value.getHours() === hour) {\n              minute = boundary.getMinutes();\n            }\n          }\n        }\n      }\n\n      return {\n        [`${type}Year`]: year,\n        [`${type}Month`]: month,\n        [`${type}Date`]: date,\n        [`${type}Hour`]: hour,\n        [`${type}Minute`]: minute,\n      };\n    },\n\n    onCancel() {\n      this.$emit('cancel');\n    },\n\n    onConfirm() {\n      this.$emit('confirm', this.data.innerValue);\n    },\n\n    onChange() {\n      const { data } = this;\n      let value;\n\n      const picker = this.getPicker();\n      const originColumns = this.getOriginColumns();\n\n      if (data.type === 'time') {\n        const indexes = picker.getIndexes();\n        value = `${+originColumns[0].values[indexes[0]]}:${+originColumns[1]\n          .values[indexes[1]]}`;\n      } else {\n        const indexes = picker.getIndexes();\n        const values = indexes.map(\n          (value, index) => originColumns[index].values[value]\n        );\n        const year = getTrueValue(values[0]);\n        const month = getTrueValue(values[1]);\n        const maxDate = getMonthEndDay(year, month);\n        let date = getTrueValue(values[2]);\n        if (data.type === 'year-month') {\n          date = 1;\n        }\n        date = date > maxDate ? maxDate : date;\n        let hour = 0;\n        let minute = 0;\n        if (data.type === 'datetime') {\n          hour = getTrueValue(values[3]);\n          minute = getTrueValue(values[4]);\n        }\n        value = new Date(year, month - 1, date, hour, minute);\n      }\n      value = this.correctValue(value);\n\n      this.updateColumnValue(value).then(() => {\n        this.$emit('input', value);\n        this.$emit('change', picker);\n      });\n    },\n\n    updateColumnValue(value) {\n      let values: string[] = [];\n      const { type } = this.data;\n      const formatter = this.data.formatter || defaultFormatter;\n      const picker = this.getPicker();\n\n      if (type === 'time') {\n        const pair = value.split(':');\n        values = [formatter('hour', pair[0]), formatter('minute', pair[1])];\n      } else {\n        const date = new Date(value);\n        values = [\n          formatter('year', `${date.getFullYear()}`),\n          formatter('month', padZero(date.getMonth() + 1)),\n        ];\n        if (type === 'date') {\n          values.push(formatter('day', padZero(date.getDate())));\n        }\n        if (type === 'datetime') {\n          values.push(\n            formatter('day', padZero(date.getDate())),\n            formatter('hour', padZero(date.getHours())),\n            formatter('minute', padZero(date.getMinutes()))\n          );\n        }\n      }\n\n      return this.set({ innerValue: value })\n        .then(() => this.updateColumns())\n        .then(() => picker.setValues(values));\n    },\n  },\n\n  created() {\n    const innerValue = this.correctValue(this.data.value);\n    this.updateColumnValue(innerValue).then(() => {\n      this.$emit('input', innerValue);\n    });\n  },\n});",
        "expression": "VantComponent({\n  classes: ['active-class', 'toolbar-class', 'column-class'],\n\n  props: {\n    ...pickerProps,\n    value: {\n      type: null,\n      observer: 'updateValue',\n    },\n    filter: null,\n    type: {\n      type: String,\n      value: 'datetime',\n      observer: 'updateValue',\n    },\n    showToolbar: {\n      type: Boolean,\n      value: true,\n    },\n    formatter: {\n      type: null,\n      value: defaultFormatter,\n    },\n    minDate: {\n      type: Number,\n      value: new Date(currentYear - 10, 0, 1).getTime(),\n      observer: 'updateValue',\n    },\n    maxDate: {\n      type: Number,\n      value: new Date(currentYear + 10, 11, 31).getTime(),\n      observer: 'updateValue',\n    },\n    minHour: {\n      type: Number,\n      value: 0,\n      observer: 'updateValue',\n    },\n    maxHour: {\n      type: Number,\n      value: 23,\n      observer: 'updateValue',\n    },\n    minMinute: {\n      type: Number,\n      value: 0,\n      observer: 'updateValue',\n    },\n    maxMinute: {\n      type: Number,\n      value: 59,\n      observer: 'updateValue',\n    },\n  },\n\n  data: {\n    innerValue: Date.now(),\n    columns: [],\n  },\n\n  methods: {\n    updateValue() {\n      const { data } = this;\n      const val = this.correctValue(data.value);\n      const isEqual = val === data.innerValue;\n      this.updateColumnValue(val).then(() => {\n        if (!isEqual) {\n          this.$emit('input', val);\n        }\n      });\n    },\n\n    getPicker() {\n      if (this.picker == null) {\n        this.picker = this.selectComponent('.van-datetime-picker');\n\n        const { picker } = this;\n        const { setColumnValues } = picker;\n        picker.setColumnValues = (...args: any) =>\n          setColumnValues.apply(picker, [...args, false]);\n      }\n\n      return this.picker;\n    },\n\n    updateColumns() {\n      const { formatter = defaultFormatter } = this.data;\n      const results = this.getOriginColumns().map((column) => ({\n        values: column.values.map((value) => formatter(column.type, value)),\n      }));\n\n      return this.set({ columns: results });\n    },\n\n    getOriginColumns() {\n      const { filter } = this.data;\n      const results = this.getRanges().map(({ type, range }) => {\n        let values = times(range[1] - range[0] + 1, (index) => {\n          const value = range[0] + index;\n          return type === 'year' ? `${value}` : padZero(value);\n        });\n\n        if (filter) {\n          values = filter(type, values);\n        }\n\n        return { type, values };\n      });\n\n      return results;\n    },\n\n    getRanges() {\n      const { data } = this;\n      if (data.type === 'time') {\n        return [\n          {\n            type: 'hour',\n            range: [data.minHour, data.maxHour],\n          },\n          {\n            type: 'minute',\n            range: [data.minMinute, data.maxMinute],\n          },\n        ];\n      }\n\n      const {\n        maxYear,\n        maxDate,\n        maxMonth,\n        maxHour,\n        maxMinute,\n      } = this.getBoundary('max', data.innerValue);\n      const {\n        minYear,\n        minDate,\n        minMonth,\n        minHour,\n        minMinute,\n      } = this.getBoundary('min', data.innerValue);\n\n      const result = [\n        {\n          type: 'year',\n          range: [minYear, maxYear],\n        },\n        {\n          type: 'month',\n          range: [minMonth, maxMonth],\n        },\n        {\n          type: 'day',\n          range: [minDate, maxDate],\n        },\n        {\n          type: 'hour',\n          range: [minHour, maxHour],\n        },\n        {\n          type: 'minute',\n          range: [minMinute, maxMinute],\n        },\n      ];\n\n      if (data.type === 'date') result.splice(3, 2);\n      if (data.type === 'year-month') result.splice(2, 3);\n      return result;\n    },\n\n    correctValue(value: any) {\n      const { data } = this;\n      // validate value\n      const isDateType = data.type !== 'time';\n      if (isDateType && !isValidDate(value)) {\n        value = data.minDate;\n      } else if (!isDateType && !value) {\n        const { minHour } = data;\n        value = `${padZero(minHour)}:00`;\n      }\n\n      // time type\n      if (!isDateType) {\n        let [hour, minute] = value.split(':');\n        hour = padZero(range(hour, data.minHour, data.maxHour));\n        minute = padZero(range(minute, data.minMinute, data.maxMinute));\n\n        return `${hour}:${minute}`;\n      }\n\n      // date type\n      value = Math.max(value, data.minDate);\n      value = Math.min(value, data.maxDate);\n\n      return value;\n    },\n\n    getBoundary(type: string, innerValue: number) {\n      const value = new Date(innerValue);\n      const boundary = new Date(this.data[`${type}Date`]);\n      const year = boundary.getFullYear();\n      let month = 1;\n      let date = 1;\n      let hour = 0;\n      let minute = 0;\n\n      if (type === 'max') {\n        month = 12;\n        date = getMonthEndDay(value.getFullYear(), value.getMonth() + 1);\n        hour = 23;\n        minute = 59;\n      }\n\n      if (value.getFullYear() === year) {\n        month = boundary.getMonth() + 1;\n        if (value.getMonth() + 1 === month) {\n          date = boundary.getDate();\n          if (value.getDate() === date) {\n            hour = boundary.getHours();\n            if (value.getHours() === hour) {\n              minute = boundary.getMinutes();\n            }\n          }\n        }\n      }\n\n      return {\n        [`${type}Year`]: year,\n        [`${type}Month`]: month,\n        [`${type}Date`]: date,\n        [`${type}Hour`]: hour,\n        [`${type}Minute`]: minute,\n      };\n    },\n\n    onCancel() {\n      this.$emit('cancel');\n    },\n\n    onConfirm() {\n      this.$emit('confirm', this.data.innerValue);\n    },\n\n    onChange() {\n      const { data } = this;\n      let value;\n\n      const picker = this.getPicker();\n      const originColumns = this.getOriginColumns();\n\n      if (data.type === 'time') {\n        const indexes = picker.getIndexes();\n        value = `${+originColumns[0].values[indexes[0]]}:${+originColumns[1]\n          .values[indexes[1]]}`;\n      } else {\n        const indexes = picker.getIndexes();\n        const values = indexes.map(\n          (value, index) => originColumns[index].values[value]\n        );\n        const year = getTrueValue(values[0]);\n        const month = getTrueValue(values[1]);\n        const maxDate = getMonthEndDay(year, month);\n        let date = getTrueValue(values[2]);\n        if (data.type === 'year-month') {\n          date = 1;\n        }\n        date = date > maxDate ? maxDate : date;\n        let hour = 0;\n        let minute = 0;\n        if (data.type === 'datetime') {\n          hour = getTrueValue(values[3]);\n          minute = getTrueValue(values[4]);\n        }\n        value = new Date(year, month - 1, date, hour, minute);\n      }\n      value = this.correctValue(value);\n\n      this.updateColumnValue(value).then(() => {\n        this.$emit('input', value);\n        this.$emit('change', picker);\n      });\n    },\n\n    updateColumnValue(value) {\n      let values: string[] = [];\n      const { type } = this.data;\n      const formatter = this.data.formatter || defaultFormatter;\n      const picker = this.getPicker();\n\n      if (type === 'time') {\n        const pair = value.split(':');\n        values = [formatter('hour', pair[0]), formatter('minute', pair[1])];\n      } else {\n        const date = new Date(value);\n        values = [\n          formatter('year', `${date.getFullYear()}`),\n          formatter('month', padZero(date.getMonth() + 1)),\n        ];\n        if (type === 'date') {\n          values.push(formatter('day', padZero(date.getDate())));\n        }\n        if (type === 'datetime') {\n          values.push(\n            formatter('day', padZero(date.getDate())),\n            formatter('hour', padZero(date.getHours())),\n            formatter('minute', padZero(date.getMinutes()))\n          );\n        }\n      }\n\n      return this.set({ innerValue: value })\n        .then(() => this.updateColumns())\n        .then(() => picker.setValues(values));\n    },\n  },\n\n  created() {\n    const innerValue = this.correctValue(this.data.value);\n    this.updateColumnValue(innerValue).then(() => {\n      this.$emit('input', innerValue);\n    });\n  },\n})",
        "callee": "VantComponent",
        "arguments": [
          {
            "classes": [
              "'active-class'",
              "'toolbar-class'",
              "'column-class'"
            ],
            "props": {
              "value": {
                "type": "null",
                "observer": "updateValue"
              },
              "filter": "null",
              "type": {
                "type": "String",
                "value": "datetime",
                "observer": "updateValue"
              },
              "showToolbar": {
                "type": "Boolean",
                "value": "true"
              },
              "formatter": {
                "type": "null",
                "value": "defaultFormatter"
              },
              "minDate": {
                "type": "Number",
                "value": "new Date(currentYear - 10, 0, 1).getTime()",
                "observer": "updateValue"
              },
              "maxDate": {
                "type": "Number",
                "value": "new Date(currentYear + 10, 11, 31).getTime()",
                "observer": "updateValue"
              },
              "minHour": {
                "type": "Number",
                "value": "0",
                "observer": "updateValue"
              },
              "maxHour": {
                "type": "Number",
                "value": "23",
                "observer": "updateValue"
              },
              "minMinute": {
                "type": "Number",
                "value": "0",
                "observer": "updateValue"
              },
              "maxMinute": {
                "type": "Number",
                "value": "59",
                "observer": "updateValue"
              }
            },
            "data": {
              "innerValue": "Date.now()",
              "columns": []
            },
            "methods": {
              "updateValue": "updateValue() {\n      const { data } = this;\n      const val = this.correctValue(data.value);\n      const isEqual = val === data.innerValue;\n      this.updateColumnValue(val).then(() => {\n        if (!isEqual) {\n          this.$emit('input', val);\n        }\n      });\n    }",
              "getPicker": "getPicker() {\n      if (this.picker == null) {\n        this.picker = this.selectComponent('.van-datetime-picker');\n\n        const { picker } = this;\n        const { setColumnValues } = picker;\n        picker.setColumnValues = (...args: any) =>\n          setColumnValues.apply(picker, [...args, false]);\n      }\n\n      return this.picker;\n    }",
              "updateColumns": "updateColumns() {\n      const { formatter = defaultFormatter } = this.data;\n      const results = this.getOriginColumns().map((column) => ({\n        values: column.values.map((value) => formatter(column.type, value)),\n      }));\n\n      return this.set({ columns: results });\n    }",
              "getOriginColumns": "getOriginColumns() {\n      const { filter } = this.data;\n      const results = this.getRanges().map(({ type, range }) => {\n        let values = times(range[1] - range[0] + 1, (index) => {\n          const value = range[0] + index;\n          return type === 'year' ? `${value}` : padZero(value);\n        });\n\n        if (filter) {\n          values = filter(type, values);\n        }\n\n        return { type, values };\n      });\n\n      return results;\n    }",
              "getRanges": "getRanges() {\n      const { data } = this;\n      if (data.type === 'time') {\n        return [\n          {\n            type: 'hour',\n            range: [data.minHour, data.maxHour],\n          },\n          {\n            type: 'minute',\n            range: [data.minMinute, data.maxMinute],\n          },\n        ];\n      }\n\n      const {\n        maxYear,\n        maxDate,\n        maxMonth,\n        maxHour,\n        maxMinute,\n      } = this.getBoundary('max', data.innerValue);\n      const {\n        minYear,\n        minDate,\n        minMonth,\n        minHour,\n        minMinute,\n      } = this.getBoundary('min', data.innerValue);\n\n      const result = [\n        {\n          type: 'year',\n          range: [minYear, maxYear],\n        },\n        {\n          type: 'month',\n          range: [minMonth, maxMonth],\n        },\n        {\n          type: 'day',\n          range: [minDate, maxDate],\n        },\n        {\n          type: 'hour',\n          range: [minHour, maxHour],\n        },\n        {\n          type: 'minute',\n          range: [minMinute, maxMinute],\n        },\n      ];\n\n      if (data.type === 'date') result.splice(3, 2);\n      if (data.type === 'year-month') result.splice(2, 3);\n      return result;\n    }",
              "correctValue": "correctValue(value: any) {\n      const { data } = this;\n      // validate value\n      const isDateType = data.type !== 'time';\n      if (isDateType && !isValidDate(value)) {\n        value = data.minDate;\n      } else if (!isDateType && !value) {\n        const { minHour } = data;\n        value = `${padZero(minHour)}:00`;\n      }\n\n      // time type\n      if (!isDateType) {\n        let [hour, minute] = value.split(':');\n        hour = padZero(range(hour, data.minHour, data.maxHour));\n        minute = padZero(range(minute, data.minMinute, data.maxMinute));\n\n        return `${hour}:${minute}`;\n      }\n\n      // date type\n      value = Math.max(value, data.minDate);\n      value = Math.min(value, data.maxDate);\n\n      return value;\n    }",
              "getBoundary": "getBoundary(type: string, innerValue: number) {\n      const value = new Date(innerValue);\n      const boundary = new Date(this.data[`${type}Date`]);\n      const year = boundary.getFullYear();\n      let month = 1;\n      let date = 1;\n      let hour = 0;\n      let minute = 0;\n\n      if (type === 'max') {\n        month = 12;\n        date = getMonthEndDay(value.getFullYear(), value.getMonth() + 1);\n        hour = 23;\n        minute = 59;\n      }\n\n      if (value.getFullYear() === year) {\n        month = boundary.getMonth() + 1;\n        if (value.getMonth() + 1 === month) {\n          date = boundary.getDate();\n          if (value.getDate() === date) {\n            hour = boundary.getHours();\n            if (value.getHours() === hour) {\n              minute = boundary.getMinutes();\n            }\n          }\n        }\n      }\n\n      return {\n        [`${type}Year`]: year,\n        [`${type}Month`]: month,\n        [`${type}Date`]: date,\n        [`${type}Hour`]: hour,\n        [`${type}Minute`]: minute,\n      };\n    }",
              "onCancel": "onCancel() {\n      this.$emit('cancel');\n    }",
              "onConfirm": "onConfirm() {\n      this.$emit('confirm', this.data.innerValue);\n    }",
              "onChange": "onChange() {\n      const { data } = this;\n      let value;\n\n      const picker = this.getPicker();\n      const originColumns = this.getOriginColumns();\n\n      if (data.type === 'time') {\n        const indexes = picker.getIndexes();\n        value = `${+originColumns[0].values[indexes[0]]}:${+originColumns[1]\n          .values[indexes[1]]}`;\n      } else {\n        const indexes = picker.getIndexes();\n        const values = indexes.map(\n          (value, index) => originColumns[index].values[value]\n        );\n        const year = getTrueValue(values[0]);\n        const month = getTrueValue(values[1]);\n        const maxDate = getMonthEndDay(year, month);\n        let date = getTrueValue(values[2]);\n        if (data.type === 'year-month') {\n          date = 1;\n        }\n        date = date > maxDate ? maxDate : date;\n        let hour = 0;\n        let minute = 0;\n        if (data.type === 'datetime') {\n          hour = getTrueValue(values[3]);\n          minute = getTrueValue(values[4]);\n        }\n        value = new Date(year, month - 1, date, hour, minute);\n      }\n      value = this.correctValue(value);\n\n      this.updateColumnValue(value).then(() => {\n        this.$emit('input', value);\n        this.$emit('change', picker);\n      });\n    }",
              "updateColumnValue": "updateColumnValue(value) {\n      let values: string[] = [];\n      const { type } = this.data;\n      const formatter = this.data.formatter || defaultFormatter;\n      const picker = this.getPicker();\n\n      if (type === 'time') {\n        const pair = value.split(':');\n        values = [formatter('hour', pair[0]), formatter('minute', pair[1])];\n      } else {\n        const date = new Date(value);\n        values = [\n          formatter('year', `${date.getFullYear()}`),\n          formatter('month', padZero(date.getMonth() + 1)),\n        ];\n        if (type === 'date') {\n          values.push(formatter('day', padZero(date.getDate())));\n        }\n        if (type === 'datetime') {\n          values.push(\n            formatter('day', padZero(date.getDate())),\n            formatter('hour', padZero(date.getHours())),\n            formatter('minute', padZero(date.getMinutes()))\n          );\n        }\n      }\n\n      return this.set({ innerValue: value })\n        .then(() => this.updateColumns())\n        .then(() => picker.setValues(values));\n    }"
            }
          }
        ]
      }
    ]
  },
  "wxs": null,
  "wxss": ""
}