{
  "wxml": [
    {
      "tag": "div",
      "attrs": {
        "v-if": "showHeader",
        "class": "van-cascader__header"
      },
      "children": [
        {
          "tag": "slot",
          "attrs": {
            "name": "title",
            "v-if": "useTitleSlot"
          }
        },
        {
          "tag": "text",
          "attrs": {
            "class": "van-cascader__title",
            "v-else": ""
          }
        },
        {
          "tag": "van-icon",
          "attrs": {
            "v-if": "closeable",
            ":name": "closeIcon",
            "class": "van-cascader__close-icon",
            "@tap": "onClose"
          }
        }
      ]
    },
    {
      "tag": "van-tabs",
      "attrs": {
        ":active": "activeTab",
        "custom-class": "van-cascader__tabs",
        "wrap-class": "van-cascader__tabs-wrap",
        "tab-class": "van-cascader__tab",
        ":color": "activeColor",
        ":border": "false",
        ":swipeable": "swipeable",
        ":ellipsis": "ellipsis",
        "@click": "onClickTab"
      },
      "children": [
        {
          "tag": "van-tab",
          "attrs": {
            "v-for": "tabs",
            "v-for-item": "tab",
            "v-for-index": "tabIndex",
            ":key": "tabIndex",
            ":title": "tab.selected ? tab.selected[textKey] : placeholder",
            "style": "width: 100%;",
            ":title-style": "!tab.selected ? 'color: #969799;font-weight:normal;' : ''"
          },
          "children": [
            {
              "tag": "div",
              "attrs": {
                "class": "van-cascader__options"
              },
              "children": [
                {
                  "tag": "div",
                  "attrs": {
                    "v-for": "tab.options",
                    "v-for-item": "option",
                    ":key": "index",
                    ":class": "option.className }} {{ utils.optionClass(tab, valueKey, option)",
                    ":style": "utils.optionStyle({ tab, valueKey, option, activeColor })",
                    ":data-option": "option",
                    ":data-tab-index": "tabIndex",
                    "@tap": "onSelect"
                  },
                  "children": [
                    {
                      "tag": "text"
                    },
                    {
                      "tag": "van-icon",
                      "attrs": {
                        "v-if": "utils.isSelected(tab, valueKey, option)",
                        "name": "success",
                        "size": "18"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "ts": {
    "kind": "SourceFile",
    "text": "import { VantComponent } from '../common/component';\n\nenum FieldName {\n  TEXT = 'text',\n  VALUE = 'value',\n  CHILDREN = 'children',\n}\n\ntype Option = Record<string, any>;\n\ninterface ITab {\n  options: Option[];\n  selected: Option | null;\n}\n\nconst defaultFieldNames = {\n  text: FieldName.TEXT,\n  value: FieldName.VALUE,\n  children: FieldName.CHILDREN,\n};\n\nVantComponent({\n  props: {\n    title: String,\n    value: {\n      type: String,\n    },\n    placeholder: {\n      type: String,\n      value: '请选择',\n    },\n    activeColor: {\n      type: String,\n      value: '#1989fa',\n    },\n    options: {\n      type: Array,\n      value: [],\n    },\n    swipeable: {\n      type: Boolean,\n      value: false,\n    },\n    closeable: {\n      type: Boolean,\n      value: true,\n    },\n    ellipsis: {\n      type: Boolean,\n      value: true,\n    },\n    showHeader: {\n      type: Boolean,\n      value: true,\n    },\n    closeIcon: {\n      type: String,\n      value: 'cross',\n    },\n    fieldNames: {\n      type: Object,\n      value: defaultFieldNames,\n      observer: 'updateFieldNames',\n    },\n    useTitleSlot: Boolean,\n  },\n\n  data: {\n    tabs: [] as ITab[],\n    activeTab: 0,\n    textKey: FieldName.TEXT,\n    valueKey: FieldName.VALUE,\n    childrenKey: FieldName.CHILDREN,\n    innerValue: '',\n  },\n\n  watch: {\n    options() {\n      this.updateTabs();\n    },\n    value(newVal) {\n      this.updateValue(newVal);\n    },\n  },\n\n  created() {\n    this.updateTabs();\n  },\n\n  methods: {\n    updateValue(val: string) {\n      if (val !== undefined) {\n        const values = this.data.tabs.map(\n          (tab: ITab) => tab.selected && tab.selected[this.data.valueKey]\n        );\n        if (values.indexOf(val) > -1) {\n          return;\n        }\n      }\n\n      this.innerValue = val;\n\n      this.updateTabs();\n    },\n    updateFieldNames() {\n      const {\n        text = 'text',\n        value = 'value',\n        children = 'children',\n      } = this.data.fieldNames || defaultFieldNames;\n      this.setData({\n        textKey: text,\n        valueKey: value,\n        childrenKey: children,\n      });\n    },\n    getSelectedOptionsByValue(options, value) {\n      for (let i = 0; i < options.length; i++) {\n        const option = options[i];\n\n        if (option[this.data.valueKey] === value) {\n          return [option];\n        }\n\n        if (option[this.data.childrenKey]) {\n          const selectedOptions = this.getSelectedOptionsByValue(\n            option[this.data.childrenKey],\n            value\n          );\n          if (selectedOptions) {\n            return [option, ...selectedOptions];\n          }\n        }\n      }\n    },\n    updateTabs() {\n      const { options } = this.data;\n      const { innerValue } = this;\n\n      if (!options.length) {\n        return;\n      }\n\n      if (innerValue !== undefined) {\n        const selectedOptions = this.getSelectedOptionsByValue(\n          options,\n          innerValue\n        );\n\n        if (selectedOptions) {\n          let optionsCursor = options;\n\n          const tabs = selectedOptions.map((option) => {\n            const tab = {\n              options: optionsCursor,\n              selected: option,\n            };\n\n            const next = optionsCursor.find(\n              (item) => item[this.data.valueKey] === option[this.data.valueKey]\n            );\n            if (next) {\n              optionsCursor = next[this.data.childrenKey];\n            }\n\n            return tab;\n          });\n\n          if (optionsCursor) {\n            tabs.push({\n              options: optionsCursor,\n              selected: null,\n            });\n          }\n\n          this.setData({\n            tabs,\n          });\n\n          wx.nextTick(() => {\n            this.setData({\n              activeTab: tabs.length - 1,\n            });\n          });\n\n          return;\n        }\n      }\n\n      this.setData({\n        tabs: [\n          {\n            options,\n            selected: null,\n          },\n        ],\n        activeTab: 0,\n      });\n    },\n    onClose() {\n      this.$emit('close');\n    },\n    onClickTab(e) {\n      const { index: tabIndex, title } = e.detail;\n      this.$emit('click-tab', { title, tabIndex });\n      this.setData({\n        activeTab: tabIndex,\n      });\n    },\n    // 选中\n    onSelect(e) {\n      const { option, tabIndex } = e.currentTarget.dataset;\n\n      if (option && option.disabled) {\n        return;\n      }\n\n      const { valueKey, childrenKey } = this.data;\n      let { tabs } = this.data;\n\n      tabs[tabIndex].selected = option;\n\n      if (tabs.length > tabIndex + 1) {\n        tabs = tabs.slice(0, tabIndex + 1);\n      }\n\n      if (option[childrenKey]) {\n        const nextTab = {\n          options: option[childrenKey],\n          selected: null,\n        };\n\n        if (tabs[tabIndex + 1]) {\n          tabs[tabIndex + 1] = nextTab;\n        } else {\n          tabs.push(nextTab);\n        }\n\n        wx.nextTick(() => {\n          this.setData({\n            activeTab: tabIndex + 1,\n          });\n        });\n      }\n\n      this.setData({\n        tabs,\n      });\n\n      const selectedOptions = tabs.map((tab) => tab.selected).filter(Boolean);\n\n      const value = option[valueKey];\n\n      const params = {\n        value,\n        tabIndex,\n        selectedOptions,\n      };\n\n      this.innerValue = value;\n\n      this.$emit('change', params);\n\n      if (!option[childrenKey]) {\n        this.$emit('finish', params);\n      }\n    },\n  },\n});\n",
    "statements": [
      {
        "kind": "ImportDeclaration",
        "text": "import { VantComponent } from '../common/component';"
      },
      {
        "kind": "EnumDeclaration",
        "text": "enum FieldName {\n  TEXT = 'text',\n  VALUE = 'value',\n  CHILDREN = 'children',\n}",
        "name": "FieldName"
      },
      {
        "kind": "TypeAliasDeclaration",
        "text": "type Option = Record<string, any>;",
        "name": "Option"
      },
      {
        "kind": "InterfaceDeclaration",
        "text": "interface ITab {\n  options: Option[];\n  selected: Option | null;\n}",
        "name": "ITab"
      },
      {
        "kind": "FirstStatement",
        "text": "const defaultFieldNames = {\n  text: FieldName.TEXT,\n  value: FieldName.VALUE,\n  children: FieldName.CHILDREN,\n};"
      },
      {
        "kind": "ExpressionStatement",
        "text": "VantComponent({\n  props: {\n    title: String,\n    value: {\n      type: String,\n    },\n    placeholder: {\n      type: String,\n      value: '请选择',\n    },\n    activeColor: {\n      type: String,\n      value: '#1989fa',\n    },\n    options: {\n      type: Array,\n      value: [],\n    },\n    swipeable: {\n      type: Boolean,\n      value: false,\n    },\n    closeable: {\n      type: Boolean,\n      value: true,\n    },\n    ellipsis: {\n      type: Boolean,\n      value: true,\n    },\n    showHeader: {\n      type: Boolean,\n      value: true,\n    },\n    closeIcon: {\n      type: String,\n      value: 'cross',\n    },\n    fieldNames: {\n      type: Object,\n      value: defaultFieldNames,\n      observer: 'updateFieldNames',\n    },\n    useTitleSlot: Boolean,\n  },\n\n  data: {\n    tabs: [] as ITab[],\n    activeTab: 0,\n    textKey: FieldName.TEXT,\n    valueKey: FieldName.VALUE,\n    childrenKey: FieldName.CHILDREN,\n    innerValue: '',\n  },\n\n  watch: {\n    options() {\n      this.updateTabs();\n    },\n    value(newVal) {\n      this.updateValue(newVal);\n    },\n  },\n\n  created() {\n    this.updateTabs();\n  },\n\n  methods: {\n    updateValue(val: string) {\n      if (val !== undefined) {\n        const values = this.data.tabs.map(\n          (tab: ITab) => tab.selected && tab.selected[this.data.valueKey]\n        );\n        if (values.indexOf(val) > -1) {\n          return;\n        }\n      }\n\n      this.innerValue = val;\n\n      this.updateTabs();\n    },\n    updateFieldNames() {\n      const {\n        text = 'text',\n        value = 'value',\n        children = 'children',\n      } = this.data.fieldNames || defaultFieldNames;\n      this.setData({\n        textKey: text,\n        valueKey: value,\n        childrenKey: children,\n      });\n    },\n    getSelectedOptionsByValue(options, value) {\n      for (let i = 0; i < options.length; i++) {\n        const option = options[i];\n\n        if (option[this.data.valueKey] === value) {\n          return [option];\n        }\n\n        if (option[this.data.childrenKey]) {\n          const selectedOptions = this.getSelectedOptionsByValue(\n            option[this.data.childrenKey],\n            value\n          );\n          if (selectedOptions) {\n            return [option, ...selectedOptions];\n          }\n        }\n      }\n    },\n    updateTabs() {\n      const { options } = this.data;\n      const { innerValue } = this;\n\n      if (!options.length) {\n        return;\n      }\n\n      if (innerValue !== undefined) {\n        const selectedOptions = this.getSelectedOptionsByValue(\n          options,\n          innerValue\n        );\n\n        if (selectedOptions) {\n          let optionsCursor = options;\n\n          const tabs = selectedOptions.map((option) => {\n            const tab = {\n              options: optionsCursor,\n              selected: option,\n            };\n\n            const next = optionsCursor.find(\n              (item) => item[this.data.valueKey] === option[this.data.valueKey]\n            );\n            if (next) {\n              optionsCursor = next[this.data.childrenKey];\n            }\n\n            return tab;\n          });\n\n          if (optionsCursor) {\n            tabs.push({\n              options: optionsCursor,\n              selected: null,\n            });\n          }\n\n          this.setData({\n            tabs,\n          });\n\n          wx.nextTick(() => {\n            this.setData({\n              activeTab: tabs.length - 1,\n            });\n          });\n\n          return;\n        }\n      }\n\n      this.setData({\n        tabs: [\n          {\n            options,\n            selected: null,\n          },\n        ],\n        activeTab: 0,\n      });\n    },\n    onClose() {\n      this.$emit('close');\n    },\n    onClickTab(e) {\n      const { index: tabIndex, title } = e.detail;\n      this.$emit('click-tab', { title, tabIndex });\n      this.setData({\n        activeTab: tabIndex,\n      });\n    },\n    // 选中\n    onSelect(e) {\n      const { option, tabIndex } = e.currentTarget.dataset;\n\n      if (option && option.disabled) {\n        return;\n      }\n\n      const { valueKey, childrenKey } = this.data;\n      let { tabs } = this.data;\n\n      tabs[tabIndex].selected = option;\n\n      if (tabs.length > tabIndex + 1) {\n        tabs = tabs.slice(0, tabIndex + 1);\n      }\n\n      if (option[childrenKey]) {\n        const nextTab = {\n          options: option[childrenKey],\n          selected: null,\n        };\n\n        if (tabs[tabIndex + 1]) {\n          tabs[tabIndex + 1] = nextTab;\n        } else {\n          tabs.push(nextTab);\n        }\n\n        wx.nextTick(() => {\n          this.setData({\n            activeTab: tabIndex + 1,\n          });\n        });\n      }\n\n      this.setData({\n        tabs,\n      });\n\n      const selectedOptions = tabs.map((tab) => tab.selected).filter(Boolean);\n\n      const value = option[valueKey];\n\n      const params = {\n        value,\n        tabIndex,\n        selectedOptions,\n      };\n\n      this.innerValue = value;\n\n      this.$emit('change', params);\n\n      if (!option[childrenKey]) {\n        this.$emit('finish', params);\n      }\n    },\n  },\n});",
        "expression": "VantComponent({\n  props: {\n    title: String,\n    value: {\n      type: String,\n    },\n    placeholder: {\n      type: String,\n      value: '请选择',\n    },\n    activeColor: {\n      type: String,\n      value: '#1989fa',\n    },\n    options: {\n      type: Array,\n      value: [],\n    },\n    swipeable: {\n      type: Boolean,\n      value: false,\n    },\n    closeable: {\n      type: Boolean,\n      value: true,\n    },\n    ellipsis: {\n      type: Boolean,\n      value: true,\n    },\n    showHeader: {\n      type: Boolean,\n      value: true,\n    },\n    closeIcon: {\n      type: String,\n      value: 'cross',\n    },\n    fieldNames: {\n      type: Object,\n      value: defaultFieldNames,\n      observer: 'updateFieldNames',\n    },\n    useTitleSlot: Boolean,\n  },\n\n  data: {\n    tabs: [] as ITab[],\n    activeTab: 0,\n    textKey: FieldName.TEXT,\n    valueKey: FieldName.VALUE,\n    childrenKey: FieldName.CHILDREN,\n    innerValue: '',\n  },\n\n  watch: {\n    options() {\n      this.updateTabs();\n    },\n    value(newVal) {\n      this.updateValue(newVal);\n    },\n  },\n\n  created() {\n    this.updateTabs();\n  },\n\n  methods: {\n    updateValue(val: string) {\n      if (val !== undefined) {\n        const values = this.data.tabs.map(\n          (tab: ITab) => tab.selected && tab.selected[this.data.valueKey]\n        );\n        if (values.indexOf(val) > -1) {\n          return;\n        }\n      }\n\n      this.innerValue = val;\n\n      this.updateTabs();\n    },\n    updateFieldNames() {\n      const {\n        text = 'text',\n        value = 'value',\n        children = 'children',\n      } = this.data.fieldNames || defaultFieldNames;\n      this.setData({\n        textKey: text,\n        valueKey: value,\n        childrenKey: children,\n      });\n    },\n    getSelectedOptionsByValue(options, value) {\n      for (let i = 0; i < options.length; i++) {\n        const option = options[i];\n\n        if (option[this.data.valueKey] === value) {\n          return [option];\n        }\n\n        if (option[this.data.childrenKey]) {\n          const selectedOptions = this.getSelectedOptionsByValue(\n            option[this.data.childrenKey],\n            value\n          );\n          if (selectedOptions) {\n            return [option, ...selectedOptions];\n          }\n        }\n      }\n    },\n    updateTabs() {\n      const { options } = this.data;\n      const { innerValue } = this;\n\n      if (!options.length) {\n        return;\n      }\n\n      if (innerValue !== undefined) {\n        const selectedOptions = this.getSelectedOptionsByValue(\n          options,\n          innerValue\n        );\n\n        if (selectedOptions) {\n          let optionsCursor = options;\n\n          const tabs = selectedOptions.map((option) => {\n            const tab = {\n              options: optionsCursor,\n              selected: option,\n            };\n\n            const next = optionsCursor.find(\n              (item) => item[this.data.valueKey] === option[this.data.valueKey]\n            );\n            if (next) {\n              optionsCursor = next[this.data.childrenKey];\n            }\n\n            return tab;\n          });\n\n          if (optionsCursor) {\n            tabs.push({\n              options: optionsCursor,\n              selected: null,\n            });\n          }\n\n          this.setData({\n            tabs,\n          });\n\n          wx.nextTick(() => {\n            this.setData({\n              activeTab: tabs.length - 1,\n            });\n          });\n\n          return;\n        }\n      }\n\n      this.setData({\n        tabs: [\n          {\n            options,\n            selected: null,\n          },\n        ],\n        activeTab: 0,\n      });\n    },\n    onClose() {\n      this.$emit('close');\n    },\n    onClickTab(e) {\n      const { index: tabIndex, title } = e.detail;\n      this.$emit('click-tab', { title, tabIndex });\n      this.setData({\n        activeTab: tabIndex,\n      });\n    },\n    // 选中\n    onSelect(e) {\n      const { option, tabIndex } = e.currentTarget.dataset;\n\n      if (option && option.disabled) {\n        return;\n      }\n\n      const { valueKey, childrenKey } = this.data;\n      let { tabs } = this.data;\n\n      tabs[tabIndex].selected = option;\n\n      if (tabs.length > tabIndex + 1) {\n        tabs = tabs.slice(0, tabIndex + 1);\n      }\n\n      if (option[childrenKey]) {\n        const nextTab = {\n          options: option[childrenKey],\n          selected: null,\n        };\n\n        if (tabs[tabIndex + 1]) {\n          tabs[tabIndex + 1] = nextTab;\n        } else {\n          tabs.push(nextTab);\n        }\n\n        wx.nextTick(() => {\n          this.setData({\n            activeTab: tabIndex + 1,\n          });\n        });\n      }\n\n      this.setData({\n        tabs,\n      });\n\n      const selectedOptions = tabs.map((tab) => tab.selected).filter(Boolean);\n\n      const value = option[valueKey];\n\n      const params = {\n        value,\n        tabIndex,\n        selectedOptions,\n      };\n\n      this.innerValue = value;\n\n      this.$emit('change', params);\n\n      if (!option[childrenKey]) {\n        this.$emit('finish', params);\n      }\n    },\n  },\n})",
        "callee": "VantComponent",
        "arguments": [
          {
            "props": {
              "title": "String",
              "value": {
                "type": "String"
              },
              "placeholder": {
                "type": "String",
                "value": "请选择"
              },
              "activeColor": {
                "type": "String",
                "value": "#1989fa"
              },
              "options": {
                "type": "Array",
                "value": []
              },
              "swipeable": {
                "type": "Boolean",
                "value": "false"
              },
              "closeable": {
                "type": "Boolean",
                "value": "true"
              },
              "ellipsis": {
                "type": "Boolean",
                "value": "true"
              },
              "showHeader": {
                "type": "Boolean",
                "value": "true"
              },
              "closeIcon": {
                "type": "String",
                "value": "cross"
              },
              "fieldNames": {
                "type": "Object",
                "value": "defaultFieldNames",
                "observer": "updateFieldNames"
              },
              "useTitleSlot": "Boolean"
            },
            "data": {
              "tabs": "[] as ITab[]",
              "activeTab": "0",
              "textKey": "FieldName.TEXT",
              "valueKey": "FieldName.VALUE",
              "childrenKey": "FieldName.CHILDREN",
              "innerValue": ""
            },
            "watch": {},
            "methods": {
              "updateValue": "updateValue(val: string) {\n      if (val !== undefined) {\n        const values = this.data.tabs.map(\n          (tab: ITab) => tab.selected && tab.selected[this.data.valueKey]\n        );\n        if (values.indexOf(val) > -1) {\n          return;\n        }\n      }\n\n      this.innerValue = val;\n\n      this.updateTabs();\n    }",
              "updateFieldNames": "updateFieldNames() {\n      const {\n        text = 'text',\n        value = 'value',\n        children = 'children',\n      } = this.data.fieldNames || defaultFieldNames;\n      this.setData({\n        textKey: text,\n        valueKey: value,\n        childrenKey: children,\n      });\n    }",
              "getSelectedOptionsByValue": "getSelectedOptionsByValue(options, value) {\n      for (let i = 0; i < options.length; i++) {\n        const option = options[i];\n\n        if (option[this.data.valueKey] === value) {\n          return [option];\n        }\n\n        if (option[this.data.childrenKey]) {\n          const selectedOptions = this.getSelectedOptionsByValue(\n            option[this.data.childrenKey],\n            value\n          );\n          if (selectedOptions) {\n            return [option, ...selectedOptions];\n          }\n        }\n      }\n    }",
              "updateTabs": "updateTabs() {\n      const { options } = this.data;\n      const { innerValue } = this;\n\n      if (!options.length) {\n        return;\n      }\n\n      if (innerValue !== undefined) {\n        const selectedOptions = this.getSelectedOptionsByValue(\n          options,\n          innerValue\n        );\n\n        if (selectedOptions) {\n          let optionsCursor = options;\n\n          const tabs = selectedOptions.map((option) => {\n            const tab = {\n              options: optionsCursor,\n              selected: option,\n            };\n\n            const next = optionsCursor.find(\n              (item) => item[this.data.valueKey] === option[this.data.valueKey]\n            );\n            if (next) {\n              optionsCursor = next[this.data.childrenKey];\n            }\n\n            return tab;\n          });\n\n          if (optionsCursor) {\n            tabs.push({\n              options: optionsCursor,\n              selected: null,\n            });\n          }\n\n          this.setData({\n            tabs,\n          });\n\n          wx.nextTick(() => {\n            this.setData({\n              activeTab: tabs.length - 1,\n            });\n          });\n\n          return;\n        }\n      }\n\n      this.setData({\n        tabs: [\n          {\n            options,\n            selected: null,\n          },\n        ],\n        activeTab: 0,\n      });\n    }",
              "onClose": "onClose() {\n      this.$emit('close');\n    }",
              "onClickTab": "onClickTab(e) {\n      const { index: tabIndex, title } = e.detail;\n      this.$emit('click-tab', { title, tabIndex });\n      this.setData({\n        activeTab: tabIndex,\n      });\n    }",
              "onSelect": "onSelect(e) {\n      const { option, tabIndex } = e.currentTarget.dataset;\n\n      if (option && option.disabled) {\n        return;\n      }\n\n      const { valueKey, childrenKey } = this.data;\n      let { tabs } = this.data;\n\n      tabs[tabIndex].selected = option;\n\n      if (tabs.length > tabIndex + 1) {\n        tabs = tabs.slice(0, tabIndex + 1);\n      }\n\n      if (option[childrenKey]) {\n        const nextTab = {\n          options: option[childrenKey],\n          selected: null,\n        };\n\n        if (tabs[tabIndex + 1]) {\n          tabs[tabIndex + 1] = nextTab;\n        } else {\n          tabs.push(nextTab);\n        }\n\n        wx.nextTick(() => {\n          this.setData({\n            activeTab: tabIndex + 1,\n          });\n        });\n      }\n\n      this.setData({\n        tabs,\n      });\n\n      const selectedOptions = tabs.map((tab) => tab.selected).filter(Boolean);\n\n      const value = option[valueKey];\n\n      const params = {\n        value,\n        tabIndex,\n        selectedOptions,\n      };\n\n      this.innerValue = value;\n\n      this.$emit('change', params);\n\n      if (!option[childrenKey]) {\n        this.$emit('finish', params);\n      }\n    }"
            }
          }
        ]
      }
    ]
  },
  "wxs": {
    "kind": "SourceFile",
    "text": "var utils = require('../wxs/utils.wxs');\nvar style = require('../wxs/style.wxs');\n\nfunction isSelected(tab, valueKey, option) {\n  return tab.selected && tab.selected[valueKey] === option[valueKey]\n}\n\nfunction optionClass(tab, valueKey, option) {\n  return utils.bem('cascader__option', { selected: isSelected(tab, valueKey, option), disabled: option.disabled })\n}\n\nfunction optionStyle(data) {\n  var color = data.option.color || (isSelected(data.tab, data.valueKey, data.option) ? data.activeColor : undefined);\n  return style({\n    color\n  });\n}\n\n\nmodule.exports = {\n  isSelected: isSelected,\n  optionClass: optionClass,\n  optionStyle: optionStyle,\n};",
    "statements": [
      {
        "kind": "FirstStatement",
        "text": "var utils = require('../wxs/utils.wxs');"
      },
      {
        "kind": "FirstStatement",
        "text": "var style = require('../wxs/style.wxs');"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function isSelected(tab, valueKey, option) {\n  return tab.selected && tab.selected[valueKey] === option[valueKey]\n}",
        "name": "isSelected"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function optionClass(tab, valueKey, option) {\n  return utils.bem('cascader__option', { selected: isSelected(tab, valueKey, option), disabled: option.disabled })\n}",
        "name": "optionClass"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function optionStyle(data) {\n  var color = data.option.color || (isSelected(data.tab, data.valueKey, data.option) ? data.activeColor : undefined);\n  return style({\n    color\n  });\n}",
        "name": "optionStyle"
      },
      {
        "kind": "ExpressionStatement",
        "text": "module.exports = {\n  isSelected: isSelected,\n  optionClass: optionClass,\n  optionStyle: optionStyle,\n};",
        "expression": "module.exports = {\n  isSelected: isSelected,\n  optionClass: optionClass,\n  optionStyle: optionStyle,\n}"
      }
    ]
  },
  "wxss": ".van-cascader__header{align-items:center;display:flex;height:48px;justify-content:space-between;padding:0 16px}.van-cascader__title{font-size:16px;font-weight:600;line-height:20px}.van-cascader__close-icon{color:#c8c9cc;font-size:22px;height:22px}.van-cascader__tabs-wrap{height:48px!important;padding:0 8px}.van-cascader__tab{color:#323233!important;flex:none!important;font-weight:600!important;padding:0 8px!important}.van-cascader__tab--unselected{color:#969799!important;font-weight:400!important}.van-cascader__option{align-items:center;cursor:pointer;display:flex;font-size:14px;justify-content:space-between;line-height:20px;padding:10px 16px}.van-cascader__option:active{background-color:#f2f3f5}.van-cascader__option--selected{color:#1989fa;font-weight:600}.van-cascader__option--disabled{color:#c8c9cc;cursor:not-allowed}.van-cascader__option--disabled:active{background-color:initial}.van-cascader__options{-webkit-overflow-scrolling:touch;box-sizing:border-box;height:384px;overflow-y:auto;padding-top:6px}"
}