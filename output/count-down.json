{
  "wxml": [
    {
      "tag": "div",
      "attrs": {
        "class": "van-count-down"
      },
      "children": [
        {
          "tag": "slot",
          "attrs": {
            "v-if": "useSlot"
          }
        },
        {
          "tag": "template",
          "attrs": {
            "v-else": ""
          }
        }
      ]
    }
  ],
  "ts": {
    "kind": "SourceFile",
    "text": "import { VantComponent } from '../common/component';\nimport { isSameSecond, parseFormat, parseTimeData } from './utils';\n\nfunction simpleTick(fn: WechatMiniprogram.SetTimeoutCompleteCallback) {\n  return setTimeout(fn, 30);\n}\n\nVantComponent({\n  props: {\n    useSlot: Boolean,\n    millisecond: Boolean,\n    time: {\n      type: Number,\n      observer: 'reset',\n    },\n    format: {\n      type: String,\n      value: 'HH:mm:ss',\n    },\n    autoStart: {\n      type: Boolean,\n      value: true,\n    },\n  },\n\n  data: {\n    timeData: parseTimeData(0),\n    formattedTime: '0',\n  },\n\n  destroyed() {\n    clearTimeout(this.tid);\n    this.tid = null;\n  },\n\n  methods: {\n    // 开始\n    start() {\n      if (this.counting) {\n        return;\n      }\n\n      this.counting = true;\n      this.endTime = Date.now() + this.remain;\n      this.tick();\n    },\n\n    // 暂停\n    pause() {\n      this.counting = false;\n      clearTimeout(this.tid);\n    },\n\n    // 重置\n    reset() {\n      this.pause();\n      this.remain = this.data.time;\n      this.setRemain(this.remain);\n\n      if (this.data.autoStart) {\n        this.start();\n      }\n    },\n\n    tick() {\n      if (this.data.millisecond) {\n        this.microTick();\n      } else {\n        this.macroTick();\n      }\n    },\n\n    microTick() {\n      this.tid = simpleTick(() => {\n        this.setRemain(this.getRemain());\n\n        if (this.remain !== 0) {\n          this.microTick();\n        }\n      });\n    },\n\n    macroTick() {\n      this.tid = simpleTick(() => {\n        const remain = this.getRemain();\n\n        if (!isSameSecond(remain, this.remain) || remain === 0) {\n          this.setRemain(remain);\n        }\n\n        if (this.remain !== 0) {\n          this.macroTick();\n        }\n      });\n    },\n\n    getRemain() {\n      return Math.max(this.endTime - Date.now(), 0);\n    },\n\n    setRemain(remain) {\n      this.remain = remain;\n      const timeData = parseTimeData(remain);\n\n      if (this.data.useSlot) {\n        this.$emit('change', timeData);\n      }\n\n      this.setData({\n        formattedTime: parseFormat(this.data.format, timeData),\n      });\n\n      if (remain === 0) {\n        this.pause();\n        this.$emit('finish');\n      }\n    },\n  },\n});\n",
    "statements": [
      {
        "kind": "ImportDeclaration",
        "text": "import { VantComponent } from '../common/component';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { isSameSecond, parseFormat, parseTimeData } from './utils';"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function simpleTick(fn: WechatMiniprogram.SetTimeoutCompleteCallback) {\n  return setTimeout(fn, 30);\n}",
        "name": "simpleTick"
      },
      {
        "kind": "ExpressionStatement",
        "text": "VantComponent({\n  props: {\n    useSlot: Boolean,\n    millisecond: Boolean,\n    time: {\n      type: Number,\n      observer: 'reset',\n    },\n    format: {\n      type: String,\n      value: 'HH:mm:ss',\n    },\n    autoStart: {\n      type: Boolean,\n      value: true,\n    },\n  },\n\n  data: {\n    timeData: parseTimeData(0),\n    formattedTime: '0',\n  },\n\n  destroyed() {\n    clearTimeout(this.tid);\n    this.tid = null;\n  },\n\n  methods: {\n    // 开始\n    start() {\n      if (this.counting) {\n        return;\n      }\n\n      this.counting = true;\n      this.endTime = Date.now() + this.remain;\n      this.tick();\n    },\n\n    // 暂停\n    pause() {\n      this.counting = false;\n      clearTimeout(this.tid);\n    },\n\n    // 重置\n    reset() {\n      this.pause();\n      this.remain = this.data.time;\n      this.setRemain(this.remain);\n\n      if (this.data.autoStart) {\n        this.start();\n      }\n    },\n\n    tick() {\n      if (this.data.millisecond) {\n        this.microTick();\n      } else {\n        this.macroTick();\n      }\n    },\n\n    microTick() {\n      this.tid = simpleTick(() => {\n        this.setRemain(this.getRemain());\n\n        if (this.remain !== 0) {\n          this.microTick();\n        }\n      });\n    },\n\n    macroTick() {\n      this.tid = simpleTick(() => {\n        const remain = this.getRemain();\n\n        if (!isSameSecond(remain, this.remain) || remain === 0) {\n          this.setRemain(remain);\n        }\n\n        if (this.remain !== 0) {\n          this.macroTick();\n        }\n      });\n    },\n\n    getRemain() {\n      return Math.max(this.endTime - Date.now(), 0);\n    },\n\n    setRemain(remain) {\n      this.remain = remain;\n      const timeData = parseTimeData(remain);\n\n      if (this.data.useSlot) {\n        this.$emit('change', timeData);\n      }\n\n      this.setData({\n        formattedTime: parseFormat(this.data.format, timeData),\n      });\n\n      if (remain === 0) {\n        this.pause();\n        this.$emit('finish');\n      }\n    },\n  },\n});",
        "expression": "VantComponent({\n  props: {\n    useSlot: Boolean,\n    millisecond: Boolean,\n    time: {\n      type: Number,\n      observer: 'reset',\n    },\n    format: {\n      type: String,\n      value: 'HH:mm:ss',\n    },\n    autoStart: {\n      type: Boolean,\n      value: true,\n    },\n  },\n\n  data: {\n    timeData: parseTimeData(0),\n    formattedTime: '0',\n  },\n\n  destroyed() {\n    clearTimeout(this.tid);\n    this.tid = null;\n  },\n\n  methods: {\n    // 开始\n    start() {\n      if (this.counting) {\n        return;\n      }\n\n      this.counting = true;\n      this.endTime = Date.now() + this.remain;\n      this.tick();\n    },\n\n    // 暂停\n    pause() {\n      this.counting = false;\n      clearTimeout(this.tid);\n    },\n\n    // 重置\n    reset() {\n      this.pause();\n      this.remain = this.data.time;\n      this.setRemain(this.remain);\n\n      if (this.data.autoStart) {\n        this.start();\n      }\n    },\n\n    tick() {\n      if (this.data.millisecond) {\n        this.microTick();\n      } else {\n        this.macroTick();\n      }\n    },\n\n    microTick() {\n      this.tid = simpleTick(() => {\n        this.setRemain(this.getRemain());\n\n        if (this.remain !== 0) {\n          this.microTick();\n        }\n      });\n    },\n\n    macroTick() {\n      this.tid = simpleTick(() => {\n        const remain = this.getRemain();\n\n        if (!isSameSecond(remain, this.remain) || remain === 0) {\n          this.setRemain(remain);\n        }\n\n        if (this.remain !== 0) {\n          this.macroTick();\n        }\n      });\n    },\n\n    getRemain() {\n      return Math.max(this.endTime - Date.now(), 0);\n    },\n\n    setRemain(remain) {\n      this.remain = remain;\n      const timeData = parseTimeData(remain);\n\n      if (this.data.useSlot) {\n        this.$emit('change', timeData);\n      }\n\n      this.setData({\n        formattedTime: parseFormat(this.data.format, timeData),\n      });\n\n      if (remain === 0) {\n        this.pause();\n        this.$emit('finish');\n      }\n    },\n  },\n})",
        "callee": "VantComponent",
        "arguments": [
          {
            "props": {
              "useSlot": "Boolean",
              "millisecond": "Boolean",
              "time": {
                "type": "Number",
                "observer": "reset"
              },
              "format": {
                "type": "String",
                "value": "HH:mm:ss"
              },
              "autoStart": {
                "type": "Boolean",
                "value": "true"
              }
            },
            "data": {
              "timeData": "parseTimeData(0)",
              "formattedTime": "0"
            },
            "methods": {
              "start": "start() {\n      if (this.counting) {\n        return;\n      }\n\n      this.counting = true;\n      this.endTime = Date.now() + this.remain;\n      this.tick();\n    }",
              "pause": "pause() {\n      this.counting = false;\n      clearTimeout(this.tid);\n    }",
              "reset": "reset() {\n      this.pause();\n      this.remain = this.data.time;\n      this.setRemain(this.remain);\n\n      if (this.data.autoStart) {\n        this.start();\n      }\n    }",
              "tick": "tick() {\n      if (this.data.millisecond) {\n        this.microTick();\n      } else {\n        this.macroTick();\n      }\n    }",
              "microTick": "microTick() {\n      this.tid = simpleTick(() => {\n        this.setRemain(this.getRemain());\n\n        if (this.remain !== 0) {\n          this.microTick();\n        }\n      });\n    }",
              "macroTick": "macroTick() {\n      this.tid = simpleTick(() => {\n        const remain = this.getRemain();\n\n        if (!isSameSecond(remain, this.remain) || remain === 0) {\n          this.setRemain(remain);\n        }\n\n        if (this.remain !== 0) {\n          this.macroTick();\n        }\n      });\n    }",
              "getRemain": "getRemain() {\n      return Math.max(this.endTime - Date.now(), 0);\n    }",
              "setRemain": "setRemain(remain) {\n      this.remain = remain;\n      const timeData = parseTimeData(remain);\n\n      if (this.data.useSlot) {\n        this.$emit('change', timeData);\n      }\n\n      this.setData({\n        formattedTime: parseFormat(this.data.format, timeData),\n      });\n\n      if (remain === 0) {\n        this.pause();\n        this.$emit('finish');\n      }\n    }"
            }
          }
        ]
      }
    ]
  },
  "wxs": null,
  "wxss": ".van-count-down{color:var(--count-down-text-color,#323233);font-size:var(--count-down-font-size,14px);line-height:var(--count-down-line-height,20px)}"
}