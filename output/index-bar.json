{
  "wxml": [
    {
      "tag": "div",
      "attrs": {
        "class": "van-index-bar"
      },
      "children": [
        {
          "tag": "slot"
        },
        {
          "tag": "div",
          "attrs": {
            "v-if": "showSidebar",
            "class": "van-index-bar__sidebar",
            "@catch:tap": "onClick",
            "@catch:touchmove": "onTouchMove",
            "@catch:touchend": "onTouchStop",
            "@catch:touchcancel": "onTouchStop"
          },
          "children": [
            {
              "tag": "div",
              "attrs": {
                "v-for": "indexList",
                ":key": "index",
                "class": "van-index-bar__index",
                "style": "z-index: {{ zIndex + 1 }}; color: {{ activeAnchorIndex === index ? highlightColor : '' }}",
                ":data-index": "index"
              }
            }
          ]
        }
      ]
    }
  ],
  "ts": {
    "kind": "SourceFile",
    "text": "import { GREEN } from '../common/color';\nimport { VantComponent } from '../common/component';\nimport { useChildren } from '../common/relation';\nimport { getRect, isDef } from '../common/utils';\nimport { pageScrollMixin } from '../mixins/page-scroll';\n\nconst indexList = () => {\n  const indexList: string[] = [];\n  const charCodeOfA = 'A'.charCodeAt(0);\n\n  for (let i = 0; i < 26; i++) {\n    indexList.push(String.fromCharCode(charCodeOfA + i));\n  }\n\n  return indexList;\n};\n\nVantComponent({\n  relation: useChildren('index-anchor', function () {\n    this.updateData();\n  }),\n\n  props: {\n    sticky: {\n      type: Boolean,\n      value: true,\n    },\n    zIndex: {\n      type: Number,\n      value: 1,\n    },\n    highlightColor: {\n      type: String,\n      value: GREEN,\n    },\n    stickyOffsetTop: {\n      type: Number,\n      value: 0,\n    },\n    indexList: {\n      type: Array,\n      value: indexList(),\n    },\n  },\n\n  mixins: [\n    pageScrollMixin(function (event) {\n      this.scrollTop = event?.scrollTop || 0;\n      this.onScroll();\n    }),\n  ],\n\n  data: {\n    activeAnchorIndex: null,\n    showSidebar: false,\n  },\n\n  created() {\n    this.scrollTop = 0;\n  },\n\n  methods: {\n    updateData() {\n      wx.nextTick(() => {\n        if (this.timer != null) {\n          clearTimeout(this.timer);\n        }\n\n        this.timer = setTimeout(() => {\n          this.setData({\n            showSidebar: !!this.children.length,\n          });\n\n          this.setRect().then(() => {\n            this.onScroll();\n          });\n        }, 0);\n      });\n    },\n\n    setRect() {\n      return Promise.all([\n        this.setAnchorsRect(),\n        this.setListRect(),\n        this.setSiderbarRect(),\n      ]);\n    },\n\n    setAnchorsRect() {\n      return Promise.all(\n        this.children.map((anchor) =>\n          getRect(anchor, '.van-index-anchor-wrapper').then((rect) => {\n            Object.assign(anchor, {\n              height: rect.height,\n              top: rect.top + this.scrollTop,\n            });\n          })\n        )\n      );\n    },\n\n    setListRect() {\n      return getRect(this, '.van-index-bar').then((rect) => {\n        if (!isDef(rect)) {\n          return;\n        }\n        Object.assign(this, {\n          height: rect.height,\n          top: rect.top + this.scrollTop,\n        });\n      });\n    },\n\n    setSiderbarRect() {\n      return getRect(this, '.van-index-bar__sidebar').then((res) => {\n        if (!isDef(res)) {\n          return;\n        }\n        this.sidebar = {\n          height: res.height,\n          top: res.top,\n        };\n      });\n    },\n\n    setDiffData({ target, data }) {\n      const diffData = {};\n\n      Object.keys(data).forEach((key) => {\n        if (target.data[key] !== data[key]) {\n          diffData[key] = data[key];\n        }\n      });\n\n      if (Object.keys(diffData).length) {\n        target.setData(diffData);\n      }\n    },\n\n    getAnchorRect(anchor) {\n      return getRect(anchor, '.van-index-anchor-wrapper').then((rect) => ({\n        height: rect.height,\n        top: rect.top,\n      }));\n    },\n\n    getActiveAnchorIndex() {\n      const { children, scrollTop } = this;\n      const { sticky, stickyOffsetTop } = this.data;\n\n      for (let i = this.children.length - 1; i >= 0; i--) {\n        const preAnchorHeight = i > 0 ? children[i - 1].height : 0;\n        const reachTop = sticky ? preAnchorHeight + stickyOffsetTop : 0;\n\n        if (reachTop + scrollTop >= children[i].top) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n\n    onScroll() {\n      const { children = [], scrollTop } = this;\n\n      if (!children.length) {\n        return;\n      }\n\n      const { sticky, stickyOffsetTop, zIndex, highlightColor } = this.data;\n\n      const active = this.getActiveAnchorIndex();\n\n      this.setDiffData({\n        target: this,\n        data: {\n          activeAnchorIndex: active,\n        },\n      });\n\n      if (sticky) {\n        let isActiveAnchorSticky = false;\n\n        if (active !== -1) {\n          isActiveAnchorSticky =\n            children[active].top <= stickyOffsetTop + scrollTop;\n        }\n\n        children.forEach((item, index) => {\n          if (index === active) {\n            let wrapperStyle = '';\n            let anchorStyle = `\n              color: ${highlightColor};\n            `;\n\n            if (isActiveAnchorSticky) {\n              wrapperStyle = `\n                height: ${children[index].height}px;\n              `;\n\n              anchorStyle = `\n                position: fixed;\n                top: ${stickyOffsetTop}px;\n                z-index: ${zIndex};\n                color: ${highlightColor};\n              `;\n            }\n\n            this.setDiffData({\n              target: item,\n              data: {\n                active: true,\n                anchorStyle,\n                wrapperStyle,\n              },\n            });\n          } else if (index === active - 1) {\n            const currentAnchor = children[index];\n\n            const currentOffsetTop = currentAnchor.top;\n            const targetOffsetTop =\n              index === children.length - 1\n                ? this.top\n                : children[index + 1].top;\n\n            const parentOffsetHeight = targetOffsetTop - currentOffsetTop;\n            const translateY = parentOffsetHeight - currentAnchor.height;\n\n            const anchorStyle = `\n              position: relative;\n              transform: translate3d(0, ${translateY}px, 0);\n              z-index: ${zIndex};\n              color: ${highlightColor};\n            `;\n\n            this.setDiffData({\n              target: item,\n              data: {\n                active: true,\n                anchorStyle,\n              },\n            });\n          } else {\n            this.setDiffData({\n              target: item,\n              data: {\n                active: false,\n                anchorStyle: '',\n                wrapperStyle: '',\n              },\n            });\n          }\n        });\n      }\n    },\n\n    onClick(event) {\n      this.scrollToAnchor(event.target.dataset.index);\n    },\n\n    onTouchMove(event) {\n      const sidebarLength = this.children.length;\n      const touch = event.touches[0];\n      const itemHeight = this.sidebar.height / sidebarLength;\n      let index = Math.floor((touch.clientY - this.sidebar.top) / itemHeight);\n\n      if (index < 0) {\n        index = 0;\n      } else if (index > sidebarLength - 1) {\n        index = sidebarLength - 1;\n      }\n\n      this.scrollToAnchor(index);\n    },\n\n    onTouchStop() {\n      this.scrollToAnchorIndex = null;\n    },\n\n    scrollToAnchor(index) {\n      if (typeof index !== 'number' || this.scrollToAnchorIndex === index) {\n        return;\n      }\n\n      this.scrollToAnchorIndex = index;\n\n      const anchor = this.children.find(\n        (item) => item.data.index === this.data.indexList[index]\n      );\n\n      if (anchor) {\n        anchor.scrollIntoView(this.scrollTop);\n        this.$emit('select', anchor.data.index);\n      }\n    },\n  },\n});\n",
    "statements": [
      {
        "kind": "ImportDeclaration",
        "text": "import { GREEN } from '../common/color';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { VantComponent } from '../common/component';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { useChildren } from '../common/relation';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { getRect, isDef } from '../common/utils';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { pageScrollMixin } from '../mixins/page-scroll';"
      },
      {
        "kind": "FirstStatement",
        "text": "const indexList = () => {\n  const indexList: string[] = [];\n  const charCodeOfA = 'A'.charCodeAt(0);\n\n  for (let i = 0; i < 26; i++) {\n    indexList.push(String.fromCharCode(charCodeOfA + i));\n  }\n\n  return indexList;\n};"
      },
      {
        "kind": "ExpressionStatement",
        "text": "VantComponent({\n  relation: useChildren('index-anchor', function () {\n    this.updateData();\n  }),\n\n  props: {\n    sticky: {\n      type: Boolean,\n      value: true,\n    },\n    zIndex: {\n      type: Number,\n      value: 1,\n    },\n    highlightColor: {\n      type: String,\n      value: GREEN,\n    },\n    stickyOffsetTop: {\n      type: Number,\n      value: 0,\n    },\n    indexList: {\n      type: Array,\n      value: indexList(),\n    },\n  },\n\n  mixins: [\n    pageScrollMixin(function (event) {\n      this.scrollTop = event?.scrollTop || 0;\n      this.onScroll();\n    }),\n  ],\n\n  data: {\n    activeAnchorIndex: null,\n    showSidebar: false,\n  },\n\n  created() {\n    this.scrollTop = 0;\n  },\n\n  methods: {\n    updateData() {\n      wx.nextTick(() => {\n        if (this.timer != null) {\n          clearTimeout(this.timer);\n        }\n\n        this.timer = setTimeout(() => {\n          this.setData({\n            showSidebar: !!this.children.length,\n          });\n\n          this.setRect().then(() => {\n            this.onScroll();\n          });\n        }, 0);\n      });\n    },\n\n    setRect() {\n      return Promise.all([\n        this.setAnchorsRect(),\n        this.setListRect(),\n        this.setSiderbarRect(),\n      ]);\n    },\n\n    setAnchorsRect() {\n      return Promise.all(\n        this.children.map((anchor) =>\n          getRect(anchor, '.van-index-anchor-wrapper').then((rect) => {\n            Object.assign(anchor, {\n              height: rect.height,\n              top: rect.top + this.scrollTop,\n            });\n          })\n        )\n      );\n    },\n\n    setListRect() {\n      return getRect(this, '.van-index-bar').then((rect) => {\n        if (!isDef(rect)) {\n          return;\n        }\n        Object.assign(this, {\n          height: rect.height,\n          top: rect.top + this.scrollTop,\n        });\n      });\n    },\n\n    setSiderbarRect() {\n      return getRect(this, '.van-index-bar__sidebar').then((res) => {\n        if (!isDef(res)) {\n          return;\n        }\n        this.sidebar = {\n          height: res.height,\n          top: res.top,\n        };\n      });\n    },\n\n    setDiffData({ target, data }) {\n      const diffData = {};\n\n      Object.keys(data).forEach((key) => {\n        if (target.data[key] !== data[key]) {\n          diffData[key] = data[key];\n        }\n      });\n\n      if (Object.keys(diffData).length) {\n        target.setData(diffData);\n      }\n    },\n\n    getAnchorRect(anchor) {\n      return getRect(anchor, '.van-index-anchor-wrapper').then((rect) => ({\n        height: rect.height,\n        top: rect.top,\n      }));\n    },\n\n    getActiveAnchorIndex() {\n      const { children, scrollTop } = this;\n      const { sticky, stickyOffsetTop } = this.data;\n\n      for (let i = this.children.length - 1; i >= 0; i--) {\n        const preAnchorHeight = i > 0 ? children[i - 1].height : 0;\n        const reachTop = sticky ? preAnchorHeight + stickyOffsetTop : 0;\n\n        if (reachTop + scrollTop >= children[i].top) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n\n    onScroll() {\n      const { children = [], scrollTop } = this;\n\n      if (!children.length) {\n        return;\n      }\n\n      const { sticky, stickyOffsetTop, zIndex, highlightColor } = this.data;\n\n      const active = this.getActiveAnchorIndex();\n\n      this.setDiffData({\n        target: this,\n        data: {\n          activeAnchorIndex: active,\n        },\n      });\n\n      if (sticky) {\n        let isActiveAnchorSticky = false;\n\n        if (active !== -1) {\n          isActiveAnchorSticky =\n            children[active].top <= stickyOffsetTop + scrollTop;\n        }\n\n        children.forEach((item, index) => {\n          if (index === active) {\n            let wrapperStyle = '';\n            let anchorStyle = `\n              color: ${highlightColor};\n            `;\n\n            if (isActiveAnchorSticky) {\n              wrapperStyle = `\n                height: ${children[index].height}px;\n              `;\n\n              anchorStyle = `\n                position: fixed;\n                top: ${stickyOffsetTop}px;\n                z-index: ${zIndex};\n                color: ${highlightColor};\n              `;\n            }\n\n            this.setDiffData({\n              target: item,\n              data: {\n                active: true,\n                anchorStyle,\n                wrapperStyle,\n              },\n            });\n          } else if (index === active - 1) {\n            const currentAnchor = children[index];\n\n            const currentOffsetTop = currentAnchor.top;\n            const targetOffsetTop =\n              index === children.length - 1\n                ? this.top\n                : children[index + 1].top;\n\n            const parentOffsetHeight = targetOffsetTop - currentOffsetTop;\n            const translateY = parentOffsetHeight - currentAnchor.height;\n\n            const anchorStyle = `\n              position: relative;\n              transform: translate3d(0, ${translateY}px, 0);\n              z-index: ${zIndex};\n              color: ${highlightColor};\n            `;\n\n            this.setDiffData({\n              target: item,\n              data: {\n                active: true,\n                anchorStyle,\n              },\n            });\n          } else {\n            this.setDiffData({\n              target: item,\n              data: {\n                active: false,\n                anchorStyle: '',\n                wrapperStyle: '',\n              },\n            });\n          }\n        });\n      }\n    },\n\n    onClick(event) {\n      this.scrollToAnchor(event.target.dataset.index);\n    },\n\n    onTouchMove(event) {\n      const sidebarLength = this.children.length;\n      const touch = event.touches[0];\n      const itemHeight = this.sidebar.height / sidebarLength;\n      let index = Math.floor((touch.clientY - this.sidebar.top) / itemHeight);\n\n      if (index < 0) {\n        index = 0;\n      } else if (index > sidebarLength - 1) {\n        index = sidebarLength - 1;\n      }\n\n      this.scrollToAnchor(index);\n    },\n\n    onTouchStop() {\n      this.scrollToAnchorIndex = null;\n    },\n\n    scrollToAnchor(index) {\n      if (typeof index !== 'number' || this.scrollToAnchorIndex === index) {\n        return;\n      }\n\n      this.scrollToAnchorIndex = index;\n\n      const anchor = this.children.find(\n        (item) => item.data.index === this.data.indexList[index]\n      );\n\n      if (anchor) {\n        anchor.scrollIntoView(this.scrollTop);\n        this.$emit('select', anchor.data.index);\n      }\n    },\n  },\n});",
        "expression": "VantComponent({\n  relation: useChildren('index-anchor', function () {\n    this.updateData();\n  }),\n\n  props: {\n    sticky: {\n      type: Boolean,\n      value: true,\n    },\n    zIndex: {\n      type: Number,\n      value: 1,\n    },\n    highlightColor: {\n      type: String,\n      value: GREEN,\n    },\n    stickyOffsetTop: {\n      type: Number,\n      value: 0,\n    },\n    indexList: {\n      type: Array,\n      value: indexList(),\n    },\n  },\n\n  mixins: [\n    pageScrollMixin(function (event) {\n      this.scrollTop = event?.scrollTop || 0;\n      this.onScroll();\n    }),\n  ],\n\n  data: {\n    activeAnchorIndex: null,\n    showSidebar: false,\n  },\n\n  created() {\n    this.scrollTop = 0;\n  },\n\n  methods: {\n    updateData() {\n      wx.nextTick(() => {\n        if (this.timer != null) {\n          clearTimeout(this.timer);\n        }\n\n        this.timer = setTimeout(() => {\n          this.setData({\n            showSidebar: !!this.children.length,\n          });\n\n          this.setRect().then(() => {\n            this.onScroll();\n          });\n        }, 0);\n      });\n    },\n\n    setRect() {\n      return Promise.all([\n        this.setAnchorsRect(),\n        this.setListRect(),\n        this.setSiderbarRect(),\n      ]);\n    },\n\n    setAnchorsRect() {\n      return Promise.all(\n        this.children.map((anchor) =>\n          getRect(anchor, '.van-index-anchor-wrapper').then((rect) => {\n            Object.assign(anchor, {\n              height: rect.height,\n              top: rect.top + this.scrollTop,\n            });\n          })\n        )\n      );\n    },\n\n    setListRect() {\n      return getRect(this, '.van-index-bar').then((rect) => {\n        if (!isDef(rect)) {\n          return;\n        }\n        Object.assign(this, {\n          height: rect.height,\n          top: rect.top + this.scrollTop,\n        });\n      });\n    },\n\n    setSiderbarRect() {\n      return getRect(this, '.van-index-bar__sidebar').then((res) => {\n        if (!isDef(res)) {\n          return;\n        }\n        this.sidebar = {\n          height: res.height,\n          top: res.top,\n        };\n      });\n    },\n\n    setDiffData({ target, data }) {\n      const diffData = {};\n\n      Object.keys(data).forEach((key) => {\n        if (target.data[key] !== data[key]) {\n          diffData[key] = data[key];\n        }\n      });\n\n      if (Object.keys(diffData).length) {\n        target.setData(diffData);\n      }\n    },\n\n    getAnchorRect(anchor) {\n      return getRect(anchor, '.van-index-anchor-wrapper').then((rect) => ({\n        height: rect.height,\n        top: rect.top,\n      }));\n    },\n\n    getActiveAnchorIndex() {\n      const { children, scrollTop } = this;\n      const { sticky, stickyOffsetTop } = this.data;\n\n      for (let i = this.children.length - 1; i >= 0; i--) {\n        const preAnchorHeight = i > 0 ? children[i - 1].height : 0;\n        const reachTop = sticky ? preAnchorHeight + stickyOffsetTop : 0;\n\n        if (reachTop + scrollTop >= children[i].top) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n\n    onScroll() {\n      const { children = [], scrollTop } = this;\n\n      if (!children.length) {\n        return;\n      }\n\n      const { sticky, stickyOffsetTop, zIndex, highlightColor } = this.data;\n\n      const active = this.getActiveAnchorIndex();\n\n      this.setDiffData({\n        target: this,\n        data: {\n          activeAnchorIndex: active,\n        },\n      });\n\n      if (sticky) {\n        let isActiveAnchorSticky = false;\n\n        if (active !== -1) {\n          isActiveAnchorSticky =\n            children[active].top <= stickyOffsetTop + scrollTop;\n        }\n\n        children.forEach((item, index) => {\n          if (index === active) {\n            let wrapperStyle = '';\n            let anchorStyle = `\n              color: ${highlightColor};\n            `;\n\n            if (isActiveAnchorSticky) {\n              wrapperStyle = `\n                height: ${children[index].height}px;\n              `;\n\n              anchorStyle = `\n                position: fixed;\n                top: ${stickyOffsetTop}px;\n                z-index: ${zIndex};\n                color: ${highlightColor};\n              `;\n            }\n\n            this.setDiffData({\n              target: item,\n              data: {\n                active: true,\n                anchorStyle,\n                wrapperStyle,\n              },\n            });\n          } else if (index === active - 1) {\n            const currentAnchor = children[index];\n\n            const currentOffsetTop = currentAnchor.top;\n            const targetOffsetTop =\n              index === children.length - 1\n                ? this.top\n                : children[index + 1].top;\n\n            const parentOffsetHeight = targetOffsetTop - currentOffsetTop;\n            const translateY = parentOffsetHeight - currentAnchor.height;\n\n            const anchorStyle = `\n              position: relative;\n              transform: translate3d(0, ${translateY}px, 0);\n              z-index: ${zIndex};\n              color: ${highlightColor};\n            `;\n\n            this.setDiffData({\n              target: item,\n              data: {\n                active: true,\n                anchorStyle,\n              },\n            });\n          } else {\n            this.setDiffData({\n              target: item,\n              data: {\n                active: false,\n                anchorStyle: '',\n                wrapperStyle: '',\n              },\n            });\n          }\n        });\n      }\n    },\n\n    onClick(event) {\n      this.scrollToAnchor(event.target.dataset.index);\n    },\n\n    onTouchMove(event) {\n      const sidebarLength = this.children.length;\n      const touch = event.touches[0];\n      const itemHeight = this.sidebar.height / sidebarLength;\n      let index = Math.floor((touch.clientY - this.sidebar.top) / itemHeight);\n\n      if (index < 0) {\n        index = 0;\n      } else if (index > sidebarLength - 1) {\n        index = sidebarLength - 1;\n      }\n\n      this.scrollToAnchor(index);\n    },\n\n    onTouchStop() {\n      this.scrollToAnchorIndex = null;\n    },\n\n    scrollToAnchor(index) {\n      if (typeof index !== 'number' || this.scrollToAnchorIndex === index) {\n        return;\n      }\n\n      this.scrollToAnchorIndex = index;\n\n      const anchor = this.children.find(\n        (item) => item.data.index === this.data.indexList[index]\n      );\n\n      if (anchor) {\n        anchor.scrollIntoView(this.scrollTop);\n        this.$emit('select', anchor.data.index);\n      }\n    },\n  },\n})",
        "callee": "VantComponent",
        "arguments": [
          {
            "relation": "useChildren('index-anchor', function () {\n    this.updateData();\n  })",
            "props": {
              "sticky": {
                "type": "Boolean",
                "value": "true"
              },
              "zIndex": {
                "type": "Number",
                "value": "1"
              },
              "highlightColor": {
                "type": "String",
                "value": "GREEN"
              },
              "stickyOffsetTop": {
                "type": "Number",
                "value": "0"
              },
              "indexList": {
                "type": "Array",
                "value": "indexList()"
              }
            },
            "mixins": [
              "pageScrollMixin(function (event) {\n      this.scrollTop = event?.scrollTop || 0;\n      this.onScroll();\n    })"
            ],
            "data": {
              "activeAnchorIndex": "null",
              "showSidebar": "false"
            },
            "methods": {
              "updateData": "updateData() {\n      wx.nextTick(() => {\n        if (this.timer != null) {\n          clearTimeout(this.timer);\n        }\n\n        this.timer = setTimeout(() => {\n          this.setData({\n            showSidebar: !!this.children.length,\n          });\n\n          this.setRect().then(() => {\n            this.onScroll();\n          });\n        }, 0);\n      });\n    }",
              "setRect": "setRect() {\n      return Promise.all([\n        this.setAnchorsRect(),\n        this.setListRect(),\n        this.setSiderbarRect(),\n      ]);\n    }",
              "setAnchorsRect": "setAnchorsRect() {\n      return Promise.all(\n        this.children.map((anchor) =>\n          getRect(anchor, '.van-index-anchor-wrapper').then((rect) => {\n            Object.assign(anchor, {\n              height: rect.height,\n              top: rect.top + this.scrollTop,\n            });\n          })\n        )\n      );\n    }",
              "setListRect": "setListRect() {\n      return getRect(this, '.van-index-bar').then((rect) => {\n        if (!isDef(rect)) {\n          return;\n        }\n        Object.assign(this, {\n          height: rect.height,\n          top: rect.top + this.scrollTop,\n        });\n      });\n    }",
              "setSiderbarRect": "setSiderbarRect() {\n      return getRect(this, '.van-index-bar__sidebar').then((res) => {\n        if (!isDef(res)) {\n          return;\n        }\n        this.sidebar = {\n          height: res.height,\n          top: res.top,\n        };\n      });\n    }",
              "setDiffData": "setDiffData({ target, data }) {\n      const diffData = {};\n\n      Object.keys(data).forEach((key) => {\n        if (target.data[key] !== data[key]) {\n          diffData[key] = data[key];\n        }\n      });\n\n      if (Object.keys(diffData).length) {\n        target.setData(diffData);\n      }\n    }",
              "getAnchorRect": "getAnchorRect(anchor) {\n      return getRect(anchor, '.van-index-anchor-wrapper').then((rect) => ({\n        height: rect.height,\n        top: rect.top,\n      }));\n    }",
              "getActiveAnchorIndex": "getActiveAnchorIndex() {\n      const { children, scrollTop } = this;\n      const { sticky, stickyOffsetTop } = this.data;\n\n      for (let i = this.children.length - 1; i >= 0; i--) {\n        const preAnchorHeight = i > 0 ? children[i - 1].height : 0;\n        const reachTop = sticky ? preAnchorHeight + stickyOffsetTop : 0;\n\n        if (reachTop + scrollTop >= children[i].top) {\n          return i;\n        }\n      }\n\n      return -1;\n    }",
              "onScroll": "onScroll() {\n      const { children = [], scrollTop } = this;\n\n      if (!children.length) {\n        return;\n      }\n\n      const { sticky, stickyOffsetTop, zIndex, highlightColor } = this.data;\n\n      const active = this.getActiveAnchorIndex();\n\n      this.setDiffData({\n        target: this,\n        data: {\n          activeAnchorIndex: active,\n        },\n      });\n\n      if (sticky) {\n        let isActiveAnchorSticky = false;\n\n        if (active !== -1) {\n          isActiveAnchorSticky =\n            children[active].top <= stickyOffsetTop + scrollTop;\n        }\n\n        children.forEach((item, index) => {\n          if (index === active) {\n            let wrapperStyle = '';\n            let anchorStyle = `\n              color: ${highlightColor};\n            `;\n\n            if (isActiveAnchorSticky) {\n              wrapperStyle = `\n                height: ${children[index].height}px;\n              `;\n\n              anchorStyle = `\n                position: fixed;\n                top: ${stickyOffsetTop}px;\n                z-index: ${zIndex};\n                color: ${highlightColor};\n              `;\n            }\n\n            this.setDiffData({\n              target: item,\n              data: {\n                active: true,\n                anchorStyle,\n                wrapperStyle,\n              },\n            });\n          } else if (index === active - 1) {\n            const currentAnchor = children[index];\n\n            const currentOffsetTop = currentAnchor.top;\n            const targetOffsetTop =\n              index === children.length - 1\n                ? this.top\n                : children[index + 1].top;\n\n            const parentOffsetHeight = targetOffsetTop - currentOffsetTop;\n            const translateY = parentOffsetHeight - currentAnchor.height;\n\n            const anchorStyle = `\n              position: relative;\n              transform: translate3d(0, ${translateY}px, 0);\n              z-index: ${zIndex};\n              color: ${highlightColor};\n            `;\n\n            this.setDiffData({\n              target: item,\n              data: {\n                active: true,\n                anchorStyle,\n              },\n            });\n          } else {\n            this.setDiffData({\n              target: item,\n              data: {\n                active: false,\n                anchorStyle: '',\n                wrapperStyle: '',\n              },\n            });\n          }\n        });\n      }\n    }",
              "onClick": "onClick(event) {\n      this.scrollToAnchor(event.target.dataset.index);\n    }",
              "onTouchMove": "onTouchMove(event) {\n      const sidebarLength = this.children.length;\n      const touch = event.touches[0];\n      const itemHeight = this.sidebar.height / sidebarLength;\n      let index = Math.floor((touch.clientY - this.sidebar.top) / itemHeight);\n\n      if (index < 0) {\n        index = 0;\n      } else if (index > sidebarLength - 1) {\n        index = sidebarLength - 1;\n      }\n\n      this.scrollToAnchor(index);\n    }",
              "onTouchStop": "onTouchStop() {\n      this.scrollToAnchorIndex = null;\n    }",
              "scrollToAnchor": "scrollToAnchor(index) {\n      if (typeof index !== 'number' || this.scrollToAnchorIndex === index) {\n        return;\n      }\n\n      this.scrollToAnchorIndex = index;\n\n      const anchor = this.children.find(\n        (item) => item.data.index === this.data.indexList[index]\n      );\n\n      if (anchor) {\n        anchor.scrollIntoView(this.scrollTop);\n        this.$emit('select', anchor.data.index);\n      }\n    }"
            }
          }
        ]
      }
    ]
  },
  "wxs": null,
  "wxss": ".van-index-bar{position:relative}.van-index-bar__sidebar{display:flex;flex-direction:column;position:fixed;right:0;text-align:center;top:50%;transform:translateY(-50%);-webkit-user-select:none;user-select:none}.van-index-bar__index{font-size:var(--index-bar-index-font-size,10px);font-weight:500;line-height:var(--index-bar-index-line-height,14px);padding:0 var(--padding-base,4px) 0 var(--padding-md,16px)}"
}