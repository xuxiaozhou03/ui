{
  "wxml": [
    {
      "tag": "div",
      "attrs": {
        "class": "custom-class {{ utils.bem('tabs') }}"
      },
      "children": [
        {
          "tag": "van-sticky",
          "attrs": {
            ":disabled": "!sticky",
            ":z-index": "zIndex",
            ":offset-top": "offsetTop",
            ":container": "container",
            "@scroll": "onTouchScroll"
          },
          "children": [
            {
              "tag": "div",
              "attrs": {
                "class": "{{ utils.bem('tabs--') + type }} {{ utils.bem('tabs__wrap', { scrollable }) }} {{ type === 'line' && border ? 'van-hairline--top-bottom' : '' }} wrap-class"
              },
              "children": [
                {
                  "tag": "slot",
                  "attrs": {
                    "name": "nav-left"
                  }
                },
                {
                  "tag": "scroll-view",
                  "attrs": {
                    ":scroll-x": "scrollable",
                    ":scroll-with-animation": "scrollWithAnimation",
                    ":scroll-left": "scrollLeft",
                    ":class": "utils.bem('tabs__scroll', [type])",
                    ":style": "color ? 'border-color: ' + color : ''"
                  },
                  "children": [
                    {
                      "tag": "div",
                      "attrs": {
                        "class": "{{ utils.bem('tabs__nav', [type, { complete: !ellipsis }]) }} nav-class",
                        ":style": "navStyle"
                      },
                      "children": [
                        {
                          "tag": "div",
                          "attrs": {
                            "v-if": "type === 'line'",
                            "class": "van-tabs__line",
                            ":style": "lineStyle"
                          }
                        },
                        {
                          "tag": "div",
                          "attrs": {
                            "v-for": "tabs",
                            ":key": "index",
                            ":data-index": "index",
                            ":class": "tabClass",
                            ":style": "tabStyle",
                            "@tap": "onTap"
                          },
                          "children": [
                            {
                              "tag": "div",
                              "attrs": {
                                ":class": "ellipsis ? 'van-ellipsis' : ''",
                                ":style": "item.titleStyle"
                              },
                              "children": [
                                {
                                  "tag": "van-info",
                                  "attrs": {
                                    "v-if": "item.info !== null || item.dot",
                                    ":info": "item.info",
                                    ":dot": "item.dot",
                                    "custom-class": "van-tab__title__info"
                                  }
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "tag": "slot",
                  "attrs": {
                    "name": "nav-right"
                  }
                }
              ]
            }
          ]
        },
        {
          "tag": "div",
          "attrs": {
            "class": "van-tabs__content",
            "@touchstart": "onTouchStart",
            "@touchmove": "onTouchMove",
            "@touchend": "onTouchEnd",
            "@touchcancel": "onTouchEnd"
          },
          "children": [
            {
              "tag": "div",
              "attrs": {
                "class": "{{ utils.bem('tabs__track', [{ animated }]) }} van-tabs__track",
                ":style": "trackStyle"
              },
              "children": [
                {
                  "tag": "slot"
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "ts": {
    "kind": "SourceFile",
    "text": "import { VantComponent } from '../common/component';\nimport { touch } from '../mixins/touch';\nimport {\n  getAllRect,\n  getRect,\n  groupSetData,\n  nextTick,\n  requestAnimationFrame,\n} from '../common/utils';\nimport { isDef } from '../common/validator';\nimport { useChildren } from '../common/relation';\n\ntype TrivialInstance = WechatMiniprogram.Component.TrivialInstance;\n\nVantComponent({\n  mixins: [touch],\n\n  classes: [\n    'nav-class',\n    'tab-class',\n    'tab-active-class',\n    'line-class',\n    'wrap-class',\n  ],\n\n  relation: useChildren('tab', function () {\n    this.updateTabs();\n  }),\n\n  props: {\n    sticky: Boolean,\n    border: Boolean,\n    swipeable: Boolean,\n    titleActiveColor: String,\n    titleInactiveColor: String,\n    color: String,\n    animated: {\n      type: Boolean,\n      observer() {\n        this.children.forEach((child, index) =>\n          child.updateRender(index === this.data.currentIndex, this)\n        );\n      },\n    },\n    lineWidth: {\n      type: null,\n      value: 40,\n      observer: 'resize',\n    },\n    lineHeight: {\n      type: null,\n      value: -1,\n    },\n    active: {\n      type: null,\n      value: 0,\n      observer(name) {\n        if (name !== this.getCurrentName()) {\n          this.setCurrentIndexByName(name);\n        }\n      },\n    },\n    type: {\n      type: String,\n      value: 'line',\n    },\n    ellipsis: {\n      type: Boolean,\n      value: true,\n    },\n    duration: {\n      type: Number,\n      value: 0.3,\n    },\n    zIndex: {\n      type: Number,\n      value: 1,\n    },\n    swipeThreshold: {\n      type: Number,\n      value: 5,\n      observer(value) {\n        this.setData({\n          scrollable: this.children.length > value || !this.data.ellipsis,\n        });\n      },\n    },\n    offsetTop: {\n      type: Number,\n      value: 0,\n    },\n    lazyRender: {\n      type: Boolean,\n      value: true,\n    },\n    useBeforeChange: {\n      type: Boolean,\n      value: false,\n    },\n  },\n\n  data: {\n    tabs: [] as Record<string, unknown>[],\n    scrollLeft: 0,\n    scrollable: false,\n    currentIndex: 0,\n    container: null as unknown as () => WechatMiniprogram.NodesRef,\n    skipTransition: true,\n    scrollWithAnimation: false,\n    lineOffsetLeft: 0,\n    inited: false,\n  },\n\n  mounted() {\n    requestAnimationFrame(() => {\n      this.swiping = true;\n      this.setData({\n        container: () => this.createSelectorQuery().select('.van-tabs'),\n      });\n\n      this.resize();\n      this.scrollIntoView();\n    });\n  },\n\n  methods: {\n    updateTabs() {\n      const { children = [], data } = this;\n      this.setData({\n        tabs: children.map((child: TrivialInstance) => child.data),\n        scrollable:\n          this.children.length > data.swipeThreshold || !data.ellipsis,\n      });\n\n      this.setCurrentIndexByName(data.active || this.getCurrentName());\n    },\n\n    trigger(eventName: string, child?: TrivialInstance) {\n      const { currentIndex } = this.data;\n\n      const data = this.getChildData(currentIndex, child);\n\n      if (!isDef(data)) {\n        return;\n      }\n\n      this.$emit(eventName, data);\n    },\n\n    onTap(event: WechatMiniprogram.TouchEvent) {\n      const { index } = event.currentTarget.dataset;\n      const child = this.children[index];\n\n      if (child.data.disabled) {\n        this.trigger('disabled', child);\n        return;\n      }\n\n      this.onBeforeChange(index).then(() => {\n        this.setCurrentIndex(index);\n        nextTick(() => {\n          this.trigger('click');\n        });\n      });\n    },\n\n    // correct the index of active tab\n    setCurrentIndexByName(name) {\n      const { children = [] } = this;\n      const matched = children.filter(\n        (child: TrivialInstance) => child.getComputedName() === name\n      );\n\n      if (matched.length) {\n        this.setCurrentIndex(matched[0].index);\n      }\n    },\n\n    setCurrentIndex(currentIndex) {\n      const { data, children = [] } = this;\n\n      if (\n        !isDef(currentIndex) ||\n        currentIndex >= children.length ||\n        currentIndex < 0\n      ) {\n        return;\n      }\n\n      groupSetData(this, () => {\n        children.forEach((item: TrivialInstance, index: number) => {\n          const active = index === currentIndex;\n          if (active !== item.data.active || !item.inited) {\n            item.updateRender(active, this);\n          }\n        });\n      });\n\n      if (currentIndex === data.currentIndex) {\n        if (!data.inited) {\n          this.resize();\n        }\n        return;\n      }\n\n      const shouldEmitChange = data.currentIndex !== null;\n      this.setData({ currentIndex });\n\n      requestAnimationFrame(() => {\n        this.resize();\n        this.scrollIntoView();\n      });\n\n      nextTick(() => {\n        this.trigger('input');\n        if (shouldEmitChange) {\n          this.trigger('change');\n        }\n      });\n    },\n\n    getCurrentName() {\n      const activeTab = this.children[this.data.currentIndex];\n\n      if (activeTab) {\n        return activeTab.getComputedName();\n      }\n    },\n\n    resize() {\n      if (this.data.type !== 'line') {\n        return;\n      }\n\n      const { currentIndex, ellipsis, skipTransition } = this.data;\n\n      Promise.all([\n        getAllRect(this, '.van-tab'),\n        getRect(this, '.van-tabs__line'),\n      ]).then(([rects = [], lineRect]) => {\n        const rect = rects[currentIndex];\n\n        if (rect == null) {\n          return;\n        }\n\n        let lineOffsetLeft = rects\n          .slice(0, currentIndex)\n          .reduce((prev, curr) => prev + curr.width, 0);\n\n        lineOffsetLeft +=\n          (rect.width - lineRect.width) / 2 + (ellipsis ? 0 : 8);\n\n        this.setData({ lineOffsetLeft, inited: true });\n        this.swiping = true;\n\n        if (skipTransition) {\n          // waiting transition end\n          setTimeout(() => {\n            this.setData({ skipTransition: false });\n          }, this.data.duration);\n        }\n      });\n    },\n\n    // scroll active tab into view\n    scrollIntoView() {\n      const { currentIndex, scrollable, scrollWithAnimation } = this.data;\n\n      if (!scrollable) {\n        return;\n      }\n\n      Promise.all([\n        getAllRect(this, '.van-tab'),\n        getRect(this, '.van-tabs__nav'),\n      ]).then(([tabRects, navRect]) => {\n        const tabRect = tabRects[currentIndex];\n        const offsetLeft = tabRects\n          .slice(0, currentIndex)\n          .reduce((prev, curr) => prev + curr.width, 0);\n\n        this.setData({\n          scrollLeft: offsetLeft - (navRect.width - tabRect.width) / 2,\n        });\n\n        if (!scrollWithAnimation) {\n          nextTick(() => {\n            this.setData({ scrollWithAnimation: true });\n          });\n        }\n      });\n    },\n\n    onTouchScroll(event: WechatMiniprogram.CustomEvent) {\n      this.$emit('scroll', event.detail);\n    },\n\n    onTouchStart(event: WechatMiniprogram.TouchEvent) {\n      if (!this.data.swipeable) return;\n      this.swiping = true;\n\n      this.touchStart(event);\n    },\n\n    onTouchMove(event: WechatMiniprogram.TouchEvent) {\n      if (!this.data.swipeable || !this.swiping) return;\n\n      this.touchMove(event);\n    },\n\n    // watch swipe touch end\n    onTouchEnd() {\n      if (!this.data.swipeable || !this.swiping) return;\n\n      const { direction, deltaX, offsetX } = this;\n      const minSwipeDistance = 50;\n\n      if (direction === 'horizontal' && offsetX >= minSwipeDistance) {\n        const index = this.getAvaiableTab(deltaX);\n        if (index !== -1) {\n          this.onBeforeChange(index).then(() => this.setCurrentIndex(index));\n        }\n      }\n\n      this.swiping = false;\n    },\n\n    getAvaiableTab(direction: number) {\n      const { tabs, currentIndex } = this.data;\n      const step = direction > 0 ? -1 : 1;\n\n      for (\n        let i = step;\n        currentIndex + i < tabs.length && currentIndex + i >= 0;\n        i += step\n      ) {\n        const index = currentIndex + i;\n\n        if (\n          index >= 0 &&\n          index < tabs.length &&\n          tabs[index] &&\n          !tabs[index].disabled\n        ) {\n          return index;\n        }\n      }\n\n      return -1;\n    },\n    onBeforeChange(index: number): Promise<void> {\n      const { useBeforeChange } = this.data;\n\n      if (!useBeforeChange) {\n        return Promise.resolve();\n      }\n\n      return new Promise((resolve, reject) => {\n        this.$emit('before-change', {\n          ...this.getChildData(index),\n          callback: (status) => (status ? resolve() : reject()),\n        });\n      });\n    },\n    getChildData(index: number, child?: TrivialInstance) {\n      const currentChild = child || this.children[index];\n\n      if (!isDef(currentChild)) {\n        return;\n      }\n\n      return {\n        index: currentChild.index,\n        name: currentChild.getComputedName(),\n        title: currentChild.data.title,\n      };\n    },\n  },\n});\n",
    "statements": [
      {
        "kind": "ImportDeclaration",
        "text": "import { VantComponent } from '../common/component';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { touch } from '../mixins/touch';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import {\n  getAllRect,\n  getRect,\n  groupSetData,\n  nextTick,\n  requestAnimationFrame,\n} from '../common/utils';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { isDef } from '../common/validator';"
      },
      {
        "kind": "ImportDeclaration",
        "text": "import { useChildren } from '../common/relation';"
      },
      {
        "kind": "TypeAliasDeclaration",
        "text": "type TrivialInstance = WechatMiniprogram.Component.TrivialInstance;",
        "name": "TrivialInstance"
      },
      {
        "kind": "ExpressionStatement",
        "text": "VantComponent({\n  mixins: [touch],\n\n  classes: [\n    'nav-class',\n    'tab-class',\n    'tab-active-class',\n    'line-class',\n    'wrap-class',\n  ],\n\n  relation: useChildren('tab', function () {\n    this.updateTabs();\n  }),\n\n  props: {\n    sticky: Boolean,\n    border: Boolean,\n    swipeable: Boolean,\n    titleActiveColor: String,\n    titleInactiveColor: String,\n    color: String,\n    animated: {\n      type: Boolean,\n      observer() {\n        this.children.forEach((child, index) =>\n          child.updateRender(index === this.data.currentIndex, this)\n        );\n      },\n    },\n    lineWidth: {\n      type: null,\n      value: 40,\n      observer: 'resize',\n    },\n    lineHeight: {\n      type: null,\n      value: -1,\n    },\n    active: {\n      type: null,\n      value: 0,\n      observer(name) {\n        if (name !== this.getCurrentName()) {\n          this.setCurrentIndexByName(name);\n        }\n      },\n    },\n    type: {\n      type: String,\n      value: 'line',\n    },\n    ellipsis: {\n      type: Boolean,\n      value: true,\n    },\n    duration: {\n      type: Number,\n      value: 0.3,\n    },\n    zIndex: {\n      type: Number,\n      value: 1,\n    },\n    swipeThreshold: {\n      type: Number,\n      value: 5,\n      observer(value) {\n        this.setData({\n          scrollable: this.children.length > value || !this.data.ellipsis,\n        });\n      },\n    },\n    offsetTop: {\n      type: Number,\n      value: 0,\n    },\n    lazyRender: {\n      type: Boolean,\n      value: true,\n    },\n    useBeforeChange: {\n      type: Boolean,\n      value: false,\n    },\n  },\n\n  data: {\n    tabs: [] as Record<string, unknown>[],\n    scrollLeft: 0,\n    scrollable: false,\n    currentIndex: 0,\n    container: null as unknown as () => WechatMiniprogram.NodesRef,\n    skipTransition: true,\n    scrollWithAnimation: false,\n    lineOffsetLeft: 0,\n    inited: false,\n  },\n\n  mounted() {\n    requestAnimationFrame(() => {\n      this.swiping = true;\n      this.setData({\n        container: () => this.createSelectorQuery().select('.van-tabs'),\n      });\n\n      this.resize();\n      this.scrollIntoView();\n    });\n  },\n\n  methods: {\n    updateTabs() {\n      const { children = [], data } = this;\n      this.setData({\n        tabs: children.map((child: TrivialInstance) => child.data),\n        scrollable:\n          this.children.length > data.swipeThreshold || !data.ellipsis,\n      });\n\n      this.setCurrentIndexByName(data.active || this.getCurrentName());\n    },\n\n    trigger(eventName: string, child?: TrivialInstance) {\n      const { currentIndex } = this.data;\n\n      const data = this.getChildData(currentIndex, child);\n\n      if (!isDef(data)) {\n        return;\n      }\n\n      this.$emit(eventName, data);\n    },\n\n    onTap(event: WechatMiniprogram.TouchEvent) {\n      const { index } = event.currentTarget.dataset;\n      const child = this.children[index];\n\n      if (child.data.disabled) {\n        this.trigger('disabled', child);\n        return;\n      }\n\n      this.onBeforeChange(index).then(() => {\n        this.setCurrentIndex(index);\n        nextTick(() => {\n          this.trigger('click');\n        });\n      });\n    },\n\n    // correct the index of active tab\n    setCurrentIndexByName(name) {\n      const { children = [] } = this;\n      const matched = children.filter(\n        (child: TrivialInstance) => child.getComputedName() === name\n      );\n\n      if (matched.length) {\n        this.setCurrentIndex(matched[0].index);\n      }\n    },\n\n    setCurrentIndex(currentIndex) {\n      const { data, children = [] } = this;\n\n      if (\n        !isDef(currentIndex) ||\n        currentIndex >= children.length ||\n        currentIndex < 0\n      ) {\n        return;\n      }\n\n      groupSetData(this, () => {\n        children.forEach((item: TrivialInstance, index: number) => {\n          const active = index === currentIndex;\n          if (active !== item.data.active || !item.inited) {\n            item.updateRender(active, this);\n          }\n        });\n      });\n\n      if (currentIndex === data.currentIndex) {\n        if (!data.inited) {\n          this.resize();\n        }\n        return;\n      }\n\n      const shouldEmitChange = data.currentIndex !== null;\n      this.setData({ currentIndex });\n\n      requestAnimationFrame(() => {\n        this.resize();\n        this.scrollIntoView();\n      });\n\n      nextTick(() => {\n        this.trigger('input');\n        if (shouldEmitChange) {\n          this.trigger('change');\n        }\n      });\n    },\n\n    getCurrentName() {\n      const activeTab = this.children[this.data.currentIndex];\n\n      if (activeTab) {\n        return activeTab.getComputedName();\n      }\n    },\n\n    resize() {\n      if (this.data.type !== 'line') {\n        return;\n      }\n\n      const { currentIndex, ellipsis, skipTransition } = this.data;\n\n      Promise.all([\n        getAllRect(this, '.van-tab'),\n        getRect(this, '.van-tabs__line'),\n      ]).then(([rects = [], lineRect]) => {\n        const rect = rects[currentIndex];\n\n        if (rect == null) {\n          return;\n        }\n\n        let lineOffsetLeft = rects\n          .slice(0, currentIndex)\n          .reduce((prev, curr) => prev + curr.width, 0);\n\n        lineOffsetLeft +=\n          (rect.width - lineRect.width) / 2 + (ellipsis ? 0 : 8);\n\n        this.setData({ lineOffsetLeft, inited: true });\n        this.swiping = true;\n\n        if (skipTransition) {\n          // waiting transition end\n          setTimeout(() => {\n            this.setData({ skipTransition: false });\n          }, this.data.duration);\n        }\n      });\n    },\n\n    // scroll active tab into view\n    scrollIntoView() {\n      const { currentIndex, scrollable, scrollWithAnimation } = this.data;\n\n      if (!scrollable) {\n        return;\n      }\n\n      Promise.all([\n        getAllRect(this, '.van-tab'),\n        getRect(this, '.van-tabs__nav'),\n      ]).then(([tabRects, navRect]) => {\n        const tabRect = tabRects[currentIndex];\n        const offsetLeft = tabRects\n          .slice(0, currentIndex)\n          .reduce((prev, curr) => prev + curr.width, 0);\n\n        this.setData({\n          scrollLeft: offsetLeft - (navRect.width - tabRect.width) / 2,\n        });\n\n        if (!scrollWithAnimation) {\n          nextTick(() => {\n            this.setData({ scrollWithAnimation: true });\n          });\n        }\n      });\n    },\n\n    onTouchScroll(event: WechatMiniprogram.CustomEvent) {\n      this.$emit('scroll', event.detail);\n    },\n\n    onTouchStart(event: WechatMiniprogram.TouchEvent) {\n      if (!this.data.swipeable) return;\n      this.swiping = true;\n\n      this.touchStart(event);\n    },\n\n    onTouchMove(event: WechatMiniprogram.TouchEvent) {\n      if (!this.data.swipeable || !this.swiping) return;\n\n      this.touchMove(event);\n    },\n\n    // watch swipe touch end\n    onTouchEnd() {\n      if (!this.data.swipeable || !this.swiping) return;\n\n      const { direction, deltaX, offsetX } = this;\n      const minSwipeDistance = 50;\n\n      if (direction === 'horizontal' && offsetX >= minSwipeDistance) {\n        const index = this.getAvaiableTab(deltaX);\n        if (index !== -1) {\n          this.onBeforeChange(index).then(() => this.setCurrentIndex(index));\n        }\n      }\n\n      this.swiping = false;\n    },\n\n    getAvaiableTab(direction: number) {\n      const { tabs, currentIndex } = this.data;\n      const step = direction > 0 ? -1 : 1;\n\n      for (\n        let i = step;\n        currentIndex + i < tabs.length && currentIndex + i >= 0;\n        i += step\n      ) {\n        const index = currentIndex + i;\n\n        if (\n          index >= 0 &&\n          index < tabs.length &&\n          tabs[index] &&\n          !tabs[index].disabled\n        ) {\n          return index;\n        }\n      }\n\n      return -1;\n    },\n    onBeforeChange(index: number): Promise<void> {\n      const { useBeforeChange } = this.data;\n\n      if (!useBeforeChange) {\n        return Promise.resolve();\n      }\n\n      return new Promise((resolve, reject) => {\n        this.$emit('before-change', {\n          ...this.getChildData(index),\n          callback: (status) => (status ? resolve() : reject()),\n        });\n      });\n    },\n    getChildData(index: number, child?: TrivialInstance) {\n      const currentChild = child || this.children[index];\n\n      if (!isDef(currentChild)) {\n        return;\n      }\n\n      return {\n        index: currentChild.index,\n        name: currentChild.getComputedName(),\n        title: currentChild.data.title,\n      };\n    },\n  },\n});",
        "expression": "VantComponent({\n  mixins: [touch],\n\n  classes: [\n    'nav-class',\n    'tab-class',\n    'tab-active-class',\n    'line-class',\n    'wrap-class',\n  ],\n\n  relation: useChildren('tab', function () {\n    this.updateTabs();\n  }),\n\n  props: {\n    sticky: Boolean,\n    border: Boolean,\n    swipeable: Boolean,\n    titleActiveColor: String,\n    titleInactiveColor: String,\n    color: String,\n    animated: {\n      type: Boolean,\n      observer() {\n        this.children.forEach((child, index) =>\n          child.updateRender(index === this.data.currentIndex, this)\n        );\n      },\n    },\n    lineWidth: {\n      type: null,\n      value: 40,\n      observer: 'resize',\n    },\n    lineHeight: {\n      type: null,\n      value: -1,\n    },\n    active: {\n      type: null,\n      value: 0,\n      observer(name) {\n        if (name !== this.getCurrentName()) {\n          this.setCurrentIndexByName(name);\n        }\n      },\n    },\n    type: {\n      type: String,\n      value: 'line',\n    },\n    ellipsis: {\n      type: Boolean,\n      value: true,\n    },\n    duration: {\n      type: Number,\n      value: 0.3,\n    },\n    zIndex: {\n      type: Number,\n      value: 1,\n    },\n    swipeThreshold: {\n      type: Number,\n      value: 5,\n      observer(value) {\n        this.setData({\n          scrollable: this.children.length > value || !this.data.ellipsis,\n        });\n      },\n    },\n    offsetTop: {\n      type: Number,\n      value: 0,\n    },\n    lazyRender: {\n      type: Boolean,\n      value: true,\n    },\n    useBeforeChange: {\n      type: Boolean,\n      value: false,\n    },\n  },\n\n  data: {\n    tabs: [] as Record<string, unknown>[],\n    scrollLeft: 0,\n    scrollable: false,\n    currentIndex: 0,\n    container: null as unknown as () => WechatMiniprogram.NodesRef,\n    skipTransition: true,\n    scrollWithAnimation: false,\n    lineOffsetLeft: 0,\n    inited: false,\n  },\n\n  mounted() {\n    requestAnimationFrame(() => {\n      this.swiping = true;\n      this.setData({\n        container: () => this.createSelectorQuery().select('.van-tabs'),\n      });\n\n      this.resize();\n      this.scrollIntoView();\n    });\n  },\n\n  methods: {\n    updateTabs() {\n      const { children = [], data } = this;\n      this.setData({\n        tabs: children.map((child: TrivialInstance) => child.data),\n        scrollable:\n          this.children.length > data.swipeThreshold || !data.ellipsis,\n      });\n\n      this.setCurrentIndexByName(data.active || this.getCurrentName());\n    },\n\n    trigger(eventName: string, child?: TrivialInstance) {\n      const { currentIndex } = this.data;\n\n      const data = this.getChildData(currentIndex, child);\n\n      if (!isDef(data)) {\n        return;\n      }\n\n      this.$emit(eventName, data);\n    },\n\n    onTap(event: WechatMiniprogram.TouchEvent) {\n      const { index } = event.currentTarget.dataset;\n      const child = this.children[index];\n\n      if (child.data.disabled) {\n        this.trigger('disabled', child);\n        return;\n      }\n\n      this.onBeforeChange(index).then(() => {\n        this.setCurrentIndex(index);\n        nextTick(() => {\n          this.trigger('click');\n        });\n      });\n    },\n\n    // correct the index of active tab\n    setCurrentIndexByName(name) {\n      const { children = [] } = this;\n      const matched = children.filter(\n        (child: TrivialInstance) => child.getComputedName() === name\n      );\n\n      if (matched.length) {\n        this.setCurrentIndex(matched[0].index);\n      }\n    },\n\n    setCurrentIndex(currentIndex) {\n      const { data, children = [] } = this;\n\n      if (\n        !isDef(currentIndex) ||\n        currentIndex >= children.length ||\n        currentIndex < 0\n      ) {\n        return;\n      }\n\n      groupSetData(this, () => {\n        children.forEach((item: TrivialInstance, index: number) => {\n          const active = index === currentIndex;\n          if (active !== item.data.active || !item.inited) {\n            item.updateRender(active, this);\n          }\n        });\n      });\n\n      if (currentIndex === data.currentIndex) {\n        if (!data.inited) {\n          this.resize();\n        }\n        return;\n      }\n\n      const shouldEmitChange = data.currentIndex !== null;\n      this.setData({ currentIndex });\n\n      requestAnimationFrame(() => {\n        this.resize();\n        this.scrollIntoView();\n      });\n\n      nextTick(() => {\n        this.trigger('input');\n        if (shouldEmitChange) {\n          this.trigger('change');\n        }\n      });\n    },\n\n    getCurrentName() {\n      const activeTab = this.children[this.data.currentIndex];\n\n      if (activeTab) {\n        return activeTab.getComputedName();\n      }\n    },\n\n    resize() {\n      if (this.data.type !== 'line') {\n        return;\n      }\n\n      const { currentIndex, ellipsis, skipTransition } = this.data;\n\n      Promise.all([\n        getAllRect(this, '.van-tab'),\n        getRect(this, '.van-tabs__line'),\n      ]).then(([rects = [], lineRect]) => {\n        const rect = rects[currentIndex];\n\n        if (rect == null) {\n          return;\n        }\n\n        let lineOffsetLeft = rects\n          .slice(0, currentIndex)\n          .reduce((prev, curr) => prev + curr.width, 0);\n\n        lineOffsetLeft +=\n          (rect.width - lineRect.width) / 2 + (ellipsis ? 0 : 8);\n\n        this.setData({ lineOffsetLeft, inited: true });\n        this.swiping = true;\n\n        if (skipTransition) {\n          // waiting transition end\n          setTimeout(() => {\n            this.setData({ skipTransition: false });\n          }, this.data.duration);\n        }\n      });\n    },\n\n    // scroll active tab into view\n    scrollIntoView() {\n      const { currentIndex, scrollable, scrollWithAnimation } = this.data;\n\n      if (!scrollable) {\n        return;\n      }\n\n      Promise.all([\n        getAllRect(this, '.van-tab'),\n        getRect(this, '.van-tabs__nav'),\n      ]).then(([tabRects, navRect]) => {\n        const tabRect = tabRects[currentIndex];\n        const offsetLeft = tabRects\n          .slice(0, currentIndex)\n          .reduce((prev, curr) => prev + curr.width, 0);\n\n        this.setData({\n          scrollLeft: offsetLeft - (navRect.width - tabRect.width) / 2,\n        });\n\n        if (!scrollWithAnimation) {\n          nextTick(() => {\n            this.setData({ scrollWithAnimation: true });\n          });\n        }\n      });\n    },\n\n    onTouchScroll(event: WechatMiniprogram.CustomEvent) {\n      this.$emit('scroll', event.detail);\n    },\n\n    onTouchStart(event: WechatMiniprogram.TouchEvent) {\n      if (!this.data.swipeable) return;\n      this.swiping = true;\n\n      this.touchStart(event);\n    },\n\n    onTouchMove(event: WechatMiniprogram.TouchEvent) {\n      if (!this.data.swipeable || !this.swiping) return;\n\n      this.touchMove(event);\n    },\n\n    // watch swipe touch end\n    onTouchEnd() {\n      if (!this.data.swipeable || !this.swiping) return;\n\n      const { direction, deltaX, offsetX } = this;\n      const minSwipeDistance = 50;\n\n      if (direction === 'horizontal' && offsetX >= minSwipeDistance) {\n        const index = this.getAvaiableTab(deltaX);\n        if (index !== -1) {\n          this.onBeforeChange(index).then(() => this.setCurrentIndex(index));\n        }\n      }\n\n      this.swiping = false;\n    },\n\n    getAvaiableTab(direction: number) {\n      const { tabs, currentIndex } = this.data;\n      const step = direction > 0 ? -1 : 1;\n\n      for (\n        let i = step;\n        currentIndex + i < tabs.length && currentIndex + i >= 0;\n        i += step\n      ) {\n        const index = currentIndex + i;\n\n        if (\n          index >= 0 &&\n          index < tabs.length &&\n          tabs[index] &&\n          !tabs[index].disabled\n        ) {\n          return index;\n        }\n      }\n\n      return -1;\n    },\n    onBeforeChange(index: number): Promise<void> {\n      const { useBeforeChange } = this.data;\n\n      if (!useBeforeChange) {\n        return Promise.resolve();\n      }\n\n      return new Promise((resolve, reject) => {\n        this.$emit('before-change', {\n          ...this.getChildData(index),\n          callback: (status) => (status ? resolve() : reject()),\n        });\n      });\n    },\n    getChildData(index: number, child?: TrivialInstance) {\n      const currentChild = child || this.children[index];\n\n      if (!isDef(currentChild)) {\n        return;\n      }\n\n      return {\n        index: currentChild.index,\n        name: currentChild.getComputedName(),\n        title: currentChild.data.title,\n      };\n    },\n  },\n})",
        "callee": "VantComponent",
        "arguments": [
          {
            "mixins": [
              "touch"
            ],
            "classes": [
              "'nav-class'",
              "'tab-class'",
              "'tab-active-class'",
              "'line-class'",
              "'wrap-class'"
            ],
            "relation": "useChildren('tab', function () {\n    this.updateTabs();\n  })",
            "props": {
              "sticky": "Boolean",
              "border": "Boolean",
              "swipeable": "Boolean",
              "titleActiveColor": "String",
              "titleInactiveColor": "String",
              "color": "String",
              "animated": {
                "type": "Boolean"
              },
              "lineWidth": {
                "type": "null",
                "value": "40",
                "observer": "resize"
              },
              "lineHeight": {
                "type": "null",
                "value": "-1"
              },
              "active": {
                "type": "null",
                "value": "0"
              },
              "type": {
                "type": "String",
                "value": "line"
              },
              "ellipsis": {
                "type": "Boolean",
                "value": "true"
              },
              "duration": {
                "type": "Number",
                "value": "0.3"
              },
              "zIndex": {
                "type": "Number",
                "value": "1"
              },
              "swipeThreshold": {
                "type": "Number",
                "value": "5"
              },
              "offsetTop": {
                "type": "Number",
                "value": "0"
              },
              "lazyRender": {
                "type": "Boolean",
                "value": "true"
              },
              "useBeforeChange": {
                "type": "Boolean",
                "value": "false"
              }
            },
            "data": {
              "tabs": "[] as Record<string, unknown>[]",
              "scrollLeft": "0",
              "scrollable": "false",
              "currentIndex": "0",
              "container": "null as unknown as () => WechatMiniprogram.NodesRef",
              "skipTransition": "true",
              "scrollWithAnimation": "false",
              "lineOffsetLeft": "0",
              "inited": "false"
            },
            "methods": {
              "updateTabs": "updateTabs() {\n      const { children = [], data } = this;\n      this.setData({\n        tabs: children.map((child: TrivialInstance) => child.data),\n        scrollable:\n          this.children.length > data.swipeThreshold || !data.ellipsis,\n      });\n\n      this.setCurrentIndexByName(data.active || this.getCurrentName());\n    }",
              "trigger": "trigger(eventName: string, child?: TrivialInstance) {\n      const { currentIndex } = this.data;\n\n      const data = this.getChildData(currentIndex, child);\n\n      if (!isDef(data)) {\n        return;\n      }\n\n      this.$emit(eventName, data);\n    }",
              "onTap": "onTap(event: WechatMiniprogram.TouchEvent) {\n      const { index } = event.currentTarget.dataset;\n      const child = this.children[index];\n\n      if (child.data.disabled) {\n        this.trigger('disabled', child);\n        return;\n      }\n\n      this.onBeforeChange(index).then(() => {\n        this.setCurrentIndex(index);\n        nextTick(() => {\n          this.trigger('click');\n        });\n      });\n    }",
              "setCurrentIndexByName": "setCurrentIndexByName(name) {\n      const { children = [] } = this;\n      const matched = children.filter(\n        (child: TrivialInstance) => child.getComputedName() === name\n      );\n\n      if (matched.length) {\n        this.setCurrentIndex(matched[0].index);\n      }\n    }",
              "setCurrentIndex": "setCurrentIndex(currentIndex) {\n      const { data, children = [] } = this;\n\n      if (\n        !isDef(currentIndex) ||\n        currentIndex >= children.length ||\n        currentIndex < 0\n      ) {\n        return;\n      }\n\n      groupSetData(this, () => {\n        children.forEach((item: TrivialInstance, index: number) => {\n          const active = index === currentIndex;\n          if (active !== item.data.active || !item.inited) {\n            item.updateRender(active, this);\n          }\n        });\n      });\n\n      if (currentIndex === data.currentIndex) {\n        if (!data.inited) {\n          this.resize();\n        }\n        return;\n      }\n\n      const shouldEmitChange = data.currentIndex !== null;\n      this.setData({ currentIndex });\n\n      requestAnimationFrame(() => {\n        this.resize();\n        this.scrollIntoView();\n      });\n\n      nextTick(() => {\n        this.trigger('input');\n        if (shouldEmitChange) {\n          this.trigger('change');\n        }\n      });\n    }",
              "getCurrentName": "getCurrentName() {\n      const activeTab = this.children[this.data.currentIndex];\n\n      if (activeTab) {\n        return activeTab.getComputedName();\n      }\n    }",
              "resize": "resize() {\n      if (this.data.type !== 'line') {\n        return;\n      }\n\n      const { currentIndex, ellipsis, skipTransition } = this.data;\n\n      Promise.all([\n        getAllRect(this, '.van-tab'),\n        getRect(this, '.van-tabs__line'),\n      ]).then(([rects = [], lineRect]) => {\n        const rect = rects[currentIndex];\n\n        if (rect == null) {\n          return;\n        }\n\n        let lineOffsetLeft = rects\n          .slice(0, currentIndex)\n          .reduce((prev, curr) => prev + curr.width, 0);\n\n        lineOffsetLeft +=\n          (rect.width - lineRect.width) / 2 + (ellipsis ? 0 : 8);\n\n        this.setData({ lineOffsetLeft, inited: true });\n        this.swiping = true;\n\n        if (skipTransition) {\n          // waiting transition end\n          setTimeout(() => {\n            this.setData({ skipTransition: false });\n          }, this.data.duration);\n        }\n      });\n    }",
              "scrollIntoView": "scrollIntoView() {\n      const { currentIndex, scrollable, scrollWithAnimation } = this.data;\n\n      if (!scrollable) {\n        return;\n      }\n\n      Promise.all([\n        getAllRect(this, '.van-tab'),\n        getRect(this, '.van-tabs__nav'),\n      ]).then(([tabRects, navRect]) => {\n        const tabRect = tabRects[currentIndex];\n        const offsetLeft = tabRects\n          .slice(0, currentIndex)\n          .reduce((prev, curr) => prev + curr.width, 0);\n\n        this.setData({\n          scrollLeft: offsetLeft - (navRect.width - tabRect.width) / 2,\n        });\n\n        if (!scrollWithAnimation) {\n          nextTick(() => {\n            this.setData({ scrollWithAnimation: true });\n          });\n        }\n      });\n    }",
              "onTouchScroll": "onTouchScroll(event: WechatMiniprogram.CustomEvent) {\n      this.$emit('scroll', event.detail);\n    }",
              "onTouchStart": "onTouchStart(event: WechatMiniprogram.TouchEvent) {\n      if (!this.data.swipeable) return;\n      this.swiping = true;\n\n      this.touchStart(event);\n    }",
              "onTouchMove": "onTouchMove(event: WechatMiniprogram.TouchEvent) {\n      if (!this.data.swipeable || !this.swiping) return;\n\n      this.touchMove(event);\n    }",
              "onTouchEnd": "onTouchEnd() {\n      if (!this.data.swipeable || !this.swiping) return;\n\n      const { direction, deltaX, offsetX } = this;\n      const minSwipeDistance = 50;\n\n      if (direction === 'horizontal' && offsetX >= minSwipeDistance) {\n        const index = this.getAvaiableTab(deltaX);\n        if (index !== -1) {\n          this.onBeforeChange(index).then(() => this.setCurrentIndex(index));\n        }\n      }\n\n      this.swiping = false;\n    }",
              "getAvaiableTab": "getAvaiableTab(direction: number) {\n      const { tabs, currentIndex } = this.data;\n      const step = direction > 0 ? -1 : 1;\n\n      for (\n        let i = step;\n        currentIndex + i < tabs.length && currentIndex + i >= 0;\n        i += step\n      ) {\n        const index = currentIndex + i;\n\n        if (\n          index >= 0 &&\n          index < tabs.length &&\n          tabs[index] &&\n          !tabs[index].disabled\n        ) {\n          return index;\n        }\n      }\n\n      return -1;\n    }",
              "onBeforeChange": "onBeforeChange(index: number): Promise<void> {\n      const { useBeforeChange } = this.data;\n\n      if (!useBeforeChange) {\n        return Promise.resolve();\n      }\n\n      return new Promise((resolve, reject) => {\n        this.$emit('before-change', {\n          ...this.getChildData(index),\n          callback: (status) => (status ? resolve() : reject()),\n        });\n      });\n    }",
              "getChildData": "getChildData(index: number, child?: TrivialInstance) {\n      const currentChild = child || this.children[index];\n\n      if (!isDef(currentChild)) {\n        return;\n      }\n\n      return {\n        index: currentChild.index,\n        name: currentChild.getComputedName(),\n        title: currentChild.data.title,\n      };\n    }"
            }
          }
        ]
      }
    ]
  },
  "wxs": {
    "kind": "SourceFile",
    "text": "var utils = require('../wxs/utils.wxs');\nvar style = require('../wxs/style.wxs');\n\nfunction tabClass(active, ellipsis) {\n  var classes = ['tab-class'];\n\n  if (active) {\n    classes.push('tab-active-class');\n  }\n\n  if (ellipsis) {\n    classes.push('van-ellipsis');\n  }\n\n  return classes.join(' ');\n}\n\nfunction tabStyle(data) {\n  var titleColor = data.active\n    ? data.titleActiveColor\n    : data.titleInactiveColor;\n\n  var ellipsis = data.scrollable && data.ellipsis;\n\n  // card theme color\n  if (data.type === 'card') {\n    return style({\n      'border-color': data.color,\n      'background-color': !data.disabled && data.active ? data.color : null,\n      color: titleColor || (!data.disabled && !data.active ? data.color : null),\n      'flex-basis': ellipsis ? 88 / data.swipeThreshold + '%' : null,\n    });\n  }\n\n  return style({\n    color: titleColor,\n    'flex-basis': ellipsis ? 88 / data.swipeThreshold + '%' : null,\n  });\n}\n\nfunction navStyle(color, type) {\n  return style({\n    'border-color': type === 'card' && color ? color : null,\n  });\n}\n\nfunction trackStyle(data) {\n  if (!data.animated) {\n    return '';\n  }\n\n  return style({\n    left: -100 * data.currentIndex + '%',\n    'transition-duration': data.duration + 's',\n    '-webkit-transition-duration': data.duration + 's',\n  });\n}\n\nfunction lineStyle(data) {\n  return style({\n    width: utils.addUnit(data.lineWidth),\n    opacity: data.inited ? 1 : 0,\n    transform: 'translateX(' + data.lineOffsetLeft + 'px)',\n    '-webkit-transform': 'translateX(' + data.lineOffsetLeft + 'px)',\n    'background-color': data.color,\n    height: data.lineHeight !== -1 ? utils.addUnit(data.lineHeight) : null,\n    'border-radius':\n      data.lineHeight !== -1 ? utils.addUnit(data.lineHeight) : null,\n    'transition-duration': !data.skipTransition ? data.duration + 's' : null,\n    '-webkit-transition-duration': !data.skipTransition\n      ? data.duration + 's'\n      : null,\n  });\n}\n\nmodule.exports = {\n  tabClass: tabClass,\n  tabStyle: tabStyle,\n  trackStyle: trackStyle,\n  lineStyle: lineStyle,\n  navStyle: navStyle,\n};\n",
    "statements": [
      {
        "kind": "FirstStatement",
        "text": "var utils = require('../wxs/utils.wxs');"
      },
      {
        "kind": "FirstStatement",
        "text": "var style = require('../wxs/style.wxs');"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function tabClass(active, ellipsis) {\n  var classes = ['tab-class'];\n\n  if (active) {\n    classes.push('tab-active-class');\n  }\n\n  if (ellipsis) {\n    classes.push('van-ellipsis');\n  }\n\n  return classes.join(' ');\n}",
        "name": "tabClass"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function tabStyle(data) {\n  var titleColor = data.active\n    ? data.titleActiveColor\n    : data.titleInactiveColor;\n\n  var ellipsis = data.scrollable && data.ellipsis;\n\n  // card theme color\n  if (data.type === 'card') {\n    return style({\n      'border-color': data.color,\n      'background-color': !data.disabled && data.active ? data.color : null,\n      color: titleColor || (!data.disabled && !data.active ? data.color : null),\n      'flex-basis': ellipsis ? 88 / data.swipeThreshold + '%' : null,\n    });\n  }\n\n  return style({\n    color: titleColor,\n    'flex-basis': ellipsis ? 88 / data.swipeThreshold + '%' : null,\n  });\n}",
        "name": "tabStyle"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function navStyle(color, type) {\n  return style({\n    'border-color': type === 'card' && color ? color : null,\n  });\n}",
        "name": "navStyle"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function trackStyle(data) {\n  if (!data.animated) {\n    return '';\n  }\n\n  return style({\n    left: -100 * data.currentIndex + '%',\n    'transition-duration': data.duration + 's',\n    '-webkit-transition-duration': data.duration + 's',\n  });\n}",
        "name": "trackStyle"
      },
      {
        "kind": "FunctionDeclaration",
        "text": "function lineStyle(data) {\n  return style({\n    width: utils.addUnit(data.lineWidth),\n    opacity: data.inited ? 1 : 0,\n    transform: 'translateX(' + data.lineOffsetLeft + 'px)',\n    '-webkit-transform': 'translateX(' + data.lineOffsetLeft + 'px)',\n    'background-color': data.color,\n    height: data.lineHeight !== -1 ? utils.addUnit(data.lineHeight) : null,\n    'border-radius':\n      data.lineHeight !== -1 ? utils.addUnit(data.lineHeight) : null,\n    'transition-duration': !data.skipTransition ? data.duration + 's' : null,\n    '-webkit-transition-duration': !data.skipTransition\n      ? data.duration + 's'\n      : null,\n  });\n}",
        "name": "lineStyle"
      },
      {
        "kind": "ExpressionStatement",
        "text": "module.exports = {\n  tabClass: tabClass,\n  tabStyle: tabStyle,\n  trackStyle: trackStyle,\n  lineStyle: lineStyle,\n  navStyle: navStyle,\n};",
        "expression": "module.exports = {\n  tabClass: tabClass,\n  tabStyle: tabStyle,\n  trackStyle: trackStyle,\n  lineStyle: lineStyle,\n  navStyle: navStyle,\n}"
      }
    ]
  },
  "wxss": ".van-tabs{-webkit-tap-highlight-color:transparent;position:relative}.van-tabs__wrap{display:flex;overflow:hidden}.van-tabs__wrap--scrollable .van-tab{flex:0 0 22%}.van-tabs__wrap--scrollable .van-tab--complete{flex:1 0 auto!important;padding:0 12px}.van-tabs__wrap--scrollable .van-tabs__nav--complete{padding-left:8px;padding-right:8px}.van-tabs__scroll{background-color:var(--tabs-nav-background-color,#fff);overflow:auto}.van-tabs__scroll--line{box-sizing:initial;height:calc(100% + 15px)}.van-tabs__scroll--card{border:1px solid var(--tabs-default-color,#ee0a24);border-radius:2px;box-sizing:border-box;margin:0 var(--padding-md,16px);width:calc(100% - var(--padding-md, 16px)*2)}.van-tabs__scroll::-webkit-scrollbar{display:none}.van-tabs__nav{display:flex;position:relative;-webkit-user-select:none;user-select:none}.van-tabs__nav--card{box-sizing:border-box;height:var(--tabs-card-height,30px)}.van-tabs__nav--card .van-tab{border-right:1px solid var(--tabs-default-color,#ee0a24);color:var(--tabs-default-color,#ee0a24);line-height:calc(var(--tabs-card-height, 30px) - 2px)}.van-tabs__nav--card .van-tab:last-child{border-right:none}.van-tabs__nav--card .van-tab.van-tab--active{background-color:var(--tabs-default-color,#ee0a24);color:#fff}.van-tabs__nav--card .van-tab--disabled{color:var(--tab-disabled-text-color,#c8c9cc)}.van-tabs__line{background-color:var(--tabs-bottom-bar-color,#ee0a24);border-radius:var(--tabs-bottom-bar-height,3px);bottom:0;height:var(--tabs-bottom-bar-height,3px);left:0;opacity:0;position:absolute;z-index:1}.van-tabs__track{height:100%;position:relative;width:100%}.van-tabs__track--animated{display:flex;transition-property:left}.van-tabs__content{overflow:hidden}.van-tabs--line{height:var(--tabs-line-height,44px)}.van-tabs--card{height:var(--tabs-card-height,30px)}.van-tab{box-sizing:border-box;color:var(--tab-text-color,#646566);cursor:pointer;flex:1;font-size:var(--tab-font-size,14px);line-height:var(--tabs-line-height,44px);min-width:0;padding:0 5px;position:relative;text-align:center}.van-tab--active{color:var(--tab-active-text-color,#323233);font-weight:var(--font-weight-bold,500)}.van-tab--disabled{color:var(--tab-disabled-text-color,#c8c9cc)}.van-tab__title__info{position:relative!important;top:-1px!important;transform:translateX(0)!important}"
}